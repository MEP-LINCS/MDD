---
title: "MDD integrated data analysis by ligand"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache=FALSE, cache.lazy = FALSE, message=FALSE, warning = FALSE, fig.height=10, fig.width=12)

suppressMessages(library(tidyverse))
#library(iheatmapr)
#library(pheatmap)
library(ComplexHeatmap)
library(circlize)
library(umap)
library(cluster)
#library(plotly)
library(RColorBrewer)
library(writexl)

source("../R/MDD_functions.R")

selectFeature <- function(df){
  #browser()
  res <- df %>%
    select(feature, Type, Time, symbol) %>%
    mutate(analyte = str_remove(feature, "_.*")) %>%
    rename(assay = Type,
           time = Time) %>%
    select(feature, analyte, assay, time, symbol)
return(res)
}

create_pdfs <- FALSE
write_csvs <- FALSE

```



```{r read_data_and_metadata}
data_path <- "Data/selected_assay_pk_data.rda"
if(!file.exists(data_path)) stop("cannot load ",data_path)
load(data_path)

#Load migration distances
migration_dist <- read_csv("Data/MDD_migration_distance_lineage_T0.csv") %>%
  filter(thour == 48) %>%
  rename(ligand = treatment,
         experimentalTimePoint = thour,
         value = lineage_length_mean) %>%
  mutate(Type = "live",
         feature = "migration_distance_live",
         ligand = str_remove(ligand, "[+]EGF")) %>%
  rrscale_assay()
  
feature_gene <- read_csv("Data/MDD_Integrated_feature_gene.csv")

ifng_cluster_features <- readxl::read_excel("Data/MDD_ligand_ifng_cluster_features_UMAP_HIGHLIGHTS.xlsx",col_names = FALSE, sheet = "2") %>%
  rename("feature" = "...1") %>%
  select(feature)

clust_num <- 12
cluster_method <- "kmeans"
ligand_order <-  c("PBS", "HGF", "OSM", "EGF","BMP2+EGF", "IFNG+EGF", "TGFB+EGF")
ligand_cols <- c("CTRL" = "#7A4A2A",
                 "PBS" = "#8dd3c7",
                 "HGF" = "#80b1d3",
                 "OSM" = "#fdb462",
                 "EGF" = "#fb8072",
                 "BMP2+EGF" = "#b3de69",
                 "IFNG+EGF" = "#bebada",
                 "TGFB+EGF" = "#ffd92f")
```

## {.tabset .tabset-fade}

### heatmap

```{r Heatmaps, fig.height = 8}

# fix names, delete control T0, Hallmark pathways, reorder ligands
df_p <- selected_assay_pk_data %>%
  mutate(
    #feature = paste0(feature, "_", experimentalTimePoint),
         Type = str_replace(Type, "motifs", "motif"),
         ligand = str_replace(ligand, "ctrl", "CTRL")) %>%
  filter(!ligand == "CTRL",
         str_detect(Type,"Hallmark|pathway", negate = TRUE)) %>%
  pivot_wider(names_from = ligand) %>%
  dplyr::rename("BMP2+EGF" = "BMP2",
         "IFNG+EGF" = "IFNG",
         "TGFB+EGF" = "TGFB") %>%
  dplyr::select(all_of(ligand_order), everything())

# fix names, delete control T0, Hallmark pathways, keep long
df_p_long <-  selected_assay_pk_data %>%
  mutate(
    #feature = paste0(feature, "_", experimentalTimePoint),
         Type = str_replace(Type, "motifs", "motif"),
         ligand = str_replace(ligand, "ctrl", "CTRL")) %>%
  filter(!ligand == "CTRL",
         str_detect(Type,"Hallmark|pathway", negate = TRUE))

# fix names, keep only control/T0, delete Hallmark pathways
# divide by T0 values, spread and reorder ligand columns
# delete rows with NAs and Inf values
df_p_T0 <- selected_assay_pk_data %>%
  mutate(Type = str_replace(Type, "motifs", "motif"),
         ligand = str_replace(ligand, "ctrl", "CTRL")) %>%
  filter(ligand == "CTRL",
         str_detect(Type,"Hallmark|pathway", negate = TRUE)) %>%
  select(-experimentalTimePoint, -ligand, -Type) %>%
  rename(value_T0 = value) %>%
  #mutate_if(value_T0 == 0, value_T0 = .0001) %>%
  right_join(df_p_long, by = c("feature")) %>%
  mutate(value= log2(value/value_T0),
         feature = paste0(feature, "_", experimentalTimePoint)) %>%
  select(-value_T0) %>%
    filter(is.finite(value)) %>%
  pivot_wider(names_from = ligand) %>%
  dplyr::rename("BMP2+EGF" = "BMP2",
         "IFNG+EGF" = "IFNG",
         "TGFB+EGF" = "TGFB") %>%
  dplyr::select(all_of(ligand_order), everything()) %>%
  drop_na()

###debugging shortcut#######
df_p <- df_p_T0
#setup for common cluster colors used in heatmap and ggplot
cluster_cols <- structure(RColorBrewer::brewer.pal(12, "Paired")[c(1:9, 12, 11, 10)],
                          names = 1:clust_num)
#cluster_cols[13] <- "slategrey"
assay_cols <- structure(RColorBrewer::brewer.pal(8, "Paired")[c(6, 2:3,5, 1)],
                        names = unique(df_p$Type))
# assay_cols <- structure(RColorBrewer::brewer.pal(length(unique(df_p$Type)), "Paired")[c(6, 2:5, 1, 7:8)],
                        # names = unique(df_p$Type))

# Filter and order to this set of ligands: c("PBS", "HGF", "OSM", "EGF","BMP2", "IFNG", "TGFB")
# median summarize features that have multiple readings sych as motifs
df_p_as_matrix <- df_p %>%
  select(all_of(ligand_order)) %>%
  as.matrix()

rownames(df_p_as_matrix) <- df_p$feature
df_p_as_matrix <- df_p_as_matrix[order(rownames(df_p_as_matrix)),]

#seed the kmeans clustering with a fixed, random set of points
set.seed(42)
centers <- df_p_as_matrix[sample(1:nrow(df_p_as_matrix), size = clust_num, replace = FALSE),]
clusters <- kmeans(x = df_p_as_matrix, iter.max = 20, centers = centers)$cluster
hm_data <-tibble(feature = names(clusters),
                 Cluster = clusters) %>%
  mutate(Time = str_remove(feature, ".*_"),
         Time = as.numeric(Time),
         Type = str_remove(feature, "_[[:digit:]]*$"),
         Type = str_remove(Type, ".*_"))  %>%
  mutate(feature_sub = str_remove(feature,"_{1}[[:digit:]]*$")) %>%
  left_join(feature_gene, by = c("feature_sub" = "feature")) %>%
  dplyr::select(-feature_sub)

#Recombine data and annotations
hm_data_ann<- cbind(df_p_as_matrix, hm_data)

chm_ann <- hm_data %>%
  select(Cluster, Time, Type) %>%
  mutate(Cluster = factor(Cluster, levels = 1:clust_num, ordered = TRUE),
         Time = factor(Time, levels = c(1,4,8,24,48), ordered = TRUE)) %>%
  as.data.frame()

haRow <- HeatmapAnnotation(df = chm_ann,
                           which = "row",
                           col = list(Type = assay_cols,
                                      Time = c("1" = "azure1",
                                               "4" = "azure2",
                                               "8" = "azure3",
                                               "24" = "azure4",
                                               "48" = "black"),
                                      Cluster = factor(cluster_cols, levels = cluster_cols, ordered = TRUE)))
chm <- Heatmap(df_p_as_matrix,
               name = "LFC",
               column_title = "Selected assay data, T0 relative",
               column_title_gp = gpar(fontsize = 12),
               #col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
               #col = colorRampPalette(rev(brewer.pal(n = 7, name ="RdBu")))(100),
               cluster_rows = FALSE,
               cluster_row_slices = TRUE, 
               cluster_columns = FALSE,
               row_split = hm_data$Cluster,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = FALSE,
               row_names_gp = gpar(fontsize = 8),
               column_names_gp = gpar(fontsize = 10),
               use_raster = FALSE,
               left_annotation = haRow)
chm
if(create_pdfs){
  pdf("MDD_ligands_heatmap_T0.pdf") 
  draw(chm)
  res <- dev.off()
} 

##### Delete rows with one outlier
# Filter and order to this set of ligands: c("PBS", "HGF", "OSM", "EGF","BMP2", "IFNG", "TGFB")
#delete rows that have one outlier
identify_single_outliers <- function(x){
  obj <- boxplot.stats(unlist(x),coef = 3)
  single_outlier <- length(obj$out) == 1
  return(single_outlier)
}

clust_num <- 8
df_p_no_s_out <- df_p %>%
  rowwise() %>%
  mutate(single_outlier_row = identify_single_outliers(c_across(PBS:`TGFB+EGF`))) %>%
  filter(!single_outlier_row)

df_p_no_s_out_as_matrix <- df_p_no_s_out %>%
  select(all_of(ligand_order)) %>%
  as.matrix()

rownames(df_p_no_s_out_as_matrix) <- df_p_no_s_out$feature
df_p_no_s_out_as_matrix <- df_p_no_s_out_as_matrix[order(rownames(df_p_no_s_out_as_matrix)),]

#seed the kmeans clustering with a fixed, random set of points
set.seed(42)
centers <- df_p_no_s_out_as_matrix[sample(1:nrow(df_p_no_s_out_as_matrix), size = clust_num, replace = FALSE),]
clusters <- kmeans(x = df_p_no_s_out_as_matrix, iter.max = 20, centers = centers)$cluster
hm_data <-tibble(feature = names(clusters),
                 Cluster = clusters) %>%
  mutate(Time = str_remove(feature, ".*_"),
         Time = as.numeric(Time),
         Type = str_remove(feature, "_[[:digit:]]*$"),
         Type = str_remove(Type, ".*_"))  %>%
  mutate(feature_sub = str_remove(feature,"_{1}[[:digit:]]*$")) %>%
  left_join(feature_gene, by = c("feature_sub" = "feature")) %>%
  dplyr::select(-feature_sub)

#Recombine data and annotations
hm_data_ann<- cbind(df_p_no_s_out_as_matrix, hm_data)

chm_ann <- hm_data %>%
  select(Cluster, Time, Type) %>%
  mutate(Cluster = factor(Cluster, levels = 1:clust_num, ordered = TRUE),
         Time = factor(Time, levels = c(1,4,8,24,48), ordered = TRUE)) %>%
  as.data.frame()

haRow <- HeatmapAnnotation(df = chm_ann,
                           which = "row",
                           col = list(Type = assay_cols,
                                      Time = c("1" = "azure1",
                                               "4" = "azure2",
                                               "8" = "azure3",
                                               "24" = "azure4",
                                               "48" = "black"),
                                      Cluster = factor(cluster_cols, levels = cluster_cols, ordered = TRUE)))
chm <- Heatmap(df_p_no_s_out_as_matrix,
               name = "LFC",
               column_title = "Selected assay data, T0 relative, no single outlier",
               column_title_gp = gpar(fontsize = 12),
               #col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
               #col = colorRampPalette(rev(brewer.pal(n = 7, name ="RdBu")))(100),
               cluster_rows = FALSE,
               cluster_row_slices = TRUE, 
               cluster_columns = FALSE,
               row_split = hm_data$Cluster,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = FALSE,
               row_names_gp = gpar(fontsize = 8),
               column_names_gp = gpar(fontsize = 10),
               use_raster = FALSE,
               left_annotation = haRow)
chm
if(create_pdfs){
  pdf("MDD_ligands_heatmap_T0_delete_one_outlier_rows.pdf") 
  draw(chm)
  res <- dev.off()
} 

module_features <- hm_data_ann %>%
  select(feature, Cluster, Type, Time, symbol) %>%
  #bind_rows(reactome_pathways) %>%
  arrange(Cluster, Type) %>%
  mutate(Cluster = paste0("module_", Cluster),
         Cluster = factor(Cluster, levels = unique(Cluster))) %>%
  split(.$Cluster) %>%
   map(selectFeature)

res <- write_xlsx(module_features,
                  path = "MDD_ligand_module_no_s_outlier_features.xlsx")

#Calculate and display the correlations between the clusters
#method: calculate the average value of the responses from each ligand within each cluster
# this yields a matrix that is 12 columns with 7 rows
# calculate the correlations betweeen the columns to yield a 12x12 matrix of the correlations

df_cl <- hm_data_ann %>%
  select(-Time) %>%
  group_by(Cluster) %>%
  summarise_if(is.numeric, .funs = mean)%>%
ungroup() %>%
  #mutate(Cluster = paste0("Cl_",Cluster)) %>%
  pivot_longer(cols = -Cluster) %>%
  pivot_wider(names_from = Cluster)

df_cl_as_matrix <- df_cl %>%
  select(-name) %>%
  as.matrix 
rownames(df_cl_as_matrix) <- df_cl$name

df_cl_cors <- cor(df_cl_as_matrix)

chm <- Heatmap(df_cl_cors,
               name = "LFC",
               column_title = "MDD Integrated ligand cluster correlations, no single outlier",
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-1, 0, 1), c("#2166AC", "white", "#B2182B")),
               cluster_rows = TRUE,
               cluster_row_slices = FALSE, 
               cluster_columns = TRUE,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = TRUE,
               row_names_gp = gpar(fontsize = 10),
               column_names_gp = gpar(fontsize = 10),
               column_names_rot = 0,
               use_raster = FALSE)
draw(chm)

if(create_pdfs) {
  pdf("MDD_ligand_heatmap_cluster_correlations.pdf")
  draw(chm)
  res <- dev.off()
} 

#Create a heatmap of the corelations between the average module response and 
#the IF phenotype features



```

Main heatmap shows selected data, rrscaled then scaled across each row. Time 0 values are removed since the columns are ligands and the only "ligand" measured at time 0 was CTRL. There are `r dim(df_p_as_matrix)[1]` rows in the heatmap whith a stucture of feature_assay_time. 


```{r, eval = TRUE}

```



```{r, eval = FALSE}
df_a <- df_p_sp %>%
  arrange(Cluster, feature)

df <- df_a %>%
  select(-Cluster, -Type, -symbol)

df_cl <- df_a %>%
  select(feature, Cluster)

dfm <- df %>%
  select(-feature) %>%
  t
colnames(dfm) <- df$feature

df_cor <- dfm %>%
  cor %>%
  signif(2) %>%
  as_tibble(rownames = "feature") %>%
  left_join(df_cl, by = "feature") %>%
  select(feature, Cluster, everything())
    if(write_csvs) write_csv(df_cor, paste0("Tables/MDD_Ligand_correlations_",clust_num,".csv"))

```

###


### method  

This dataset combines MCF10A Molecular Deep Dive (MDD) RNAseq, Reverse Phase Protein Array(RPPA), Global Chromatin Profiling (GCP) histone modifications, immunofluorescence (IF) and cyclic immunofluorescence (cycIF) data. Most of the data is median summarized from three replicate experiments run in sequential weeks. It is then T0 normalized by dividing each value by the T0 value.   


This analysis is based on the LINCS Molecular Deep Dive data files on Synapse at  https://www.synapse.org/#!Synapse:syn2862345/wiki/588244.  


cycIF Values  
Select `r length(unique(cycIF_values$feature))` cycIF features based on their biological relevance  
Median summarize the values across the replicates  

GCP Values  
Median summarize the values across the replicates  
Order by variance and remove the bottom 25%.

IF Values  
Use ilastik+CellProfiler and phenotype features

RNAseq Values  
A gene list representative of the largest gene expression changes across all ligand treatments was produced from differential expression analyses of each experimental condition compared to the control condition. For each experimental condition, a differential expression analysis was performed using the R package DESeq2 (1.24.0), with shrunken log2 fold change estimates calculated using the apeglm method. Each list was filtered to include only genes with an adjusted p value < 0.05, then ranked by the absolute value of their log2 fold change estimate. The 100 most differentially expressed genes per condition were selected. Redundant genes were removed.

RPPA Values  
Median summarize the values across the replicates  
Order by variance and remove the bottom 25%.

Clustering  
k-means clustering is used with k = `r clust_num` based on gap statistic analysis.  


```{r featureTypes, fig.width=8, fig.height=4}
#create a bar chart of the feature types
df <- hm_data_ann %>%
  #drop_na() %>%
  select(feature, Type) %>%
  distinct()

p <- ggplot(hm_data_ann, aes(x = Type, fill = Type)) +
  geom_bar() +
  coord_cartesian(ylim = c(0, 10000)) +
  scale_fill_manual(values = assay_cols)+
  labs(title = paste("Type distribution of the",length(unique(paste0(hm_data_ann$feature))), "features at unique timepoints in the MDD integrated dataset"),
       x ="Feature type") +
  theme_bw()+
  theme(#axis.title = element_blank(),
    axis.text.x =  element_text(angle = 90),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())

p

p_log <- ggplot(hm_data_ann, aes(x = Type, fill = Type)) +
  geom_bar() +
  scale_y_log10() +
  scale_fill_manual(values = assay_cols)+
  labs(title = paste("Type distribution of the",length(unique(paste0(hm_data_ann$feature))), "features at unique timepoints in the MDD integrated dataset"),
       x ="Feature type") +
  theme_bw()+
  theme(#axis.title = element_blank(),
    axis.text.x =  element_text(angle = 90),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())

p_log
if(create_pdfs){
  pdf("MDD_ligands_feature_type_distribution.pdf")
  print(p)  
  res <- dev.off()
  pdf("MDD_ligands_feature_type_distribution_log_scale.pdf")
  print(p_log)
  res <- dev.off()
} 

```

###

### cluster analysis

```{r gapStatistics, fig.width=4, fig.height=4, eval = FALSE}
#implement gap statistic analysis


plot_gap_custom <- function(x) {
  gstab = data.frame(x$Tab, k = seq_len(nrow(x$Tab)))
  p <- ggplot(gstab, aes(k, gap)) + 
    geom_line() +
    geom_errorbar(aes(ymax = gap + SE.sim,
                      ymin = gap - SE.sim), width=0.1) +
    geom_point(size = .5, col=  "red") +
    labs(title = paste("Gap analysis to determine cluster number,",cluster_method)) +
     theme_bw()+
  theme(axis.ticks = element_blank(),
        panel.border = element_blank(),
       # panel.grid.major = element_blank(),
        #panel.grid.minor = element_blank(),
        axis.line =element_blank())
  return(p)
}

if(file.exists(paste0("Data/gss_",cluster_method,"_ligand_data_no_s_out.rda"))){
  load(paste0("Data/gss_",cluster_method,"_ligand_data_no_s_out.rda"))
} else {
  gss <- clusGap(df_p_no_s_out_as_matrix, FUN = kmeans, K.max = 15, B = 500, verbose = FALSE)
  save(gss, file = paste0("Data/gss_",cluster_method,"_ligand_data_no_s_out.rda"))
}

  plot_gap_custom(gss)
if(create_pdfs){
  pdf("MDD_ligands_gap_cluster_no_s_out.pdf")
  p <- plot_gap_custom(gss)
  print(p)
  res <- dev.off()
}

p <- ggplot(hm_data_ann, aes(x = as.factor(Cluster), fill = Type)) +
  geom_bar() +
  scale_fill_manual(values = assay_cols)+
  labs(x = "Cluster",
       fill = "Assay") +
  theme_bw()+
  theme(axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line =element_blank())
p
if(create_pdfs){
  pdf("MDD_ligands_assay_cluster_no_s_out.pdf")
  print(p)
  res <- dev.off()
}
```

```{r assayClusterdistribution, fig.width=8, fig.height=4, eval = FALSE}



p <- ggplot(hm_data, aes(x = as.factor(Cluster), fill = Type)) +
  geom_bar(position = "dodge") +  
  scale_fill_manual(values = assay_cols) +
  labs(x = "Cluster",
       fill = "Assay") +
  facet_wrap(~Type, scales = "free_y") +
  theme_bw()+
  theme(#axis.title = element_blank(),
    #axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())
p

if(create_pdfs){
  pdf("MDD_ligands_cluster_feature_counts_no_s_out.pdf")
  print(p)
  res <- dev.off()
} 

```


This analysis can be interpreted to select the number of clusters in the dataset. It is based on a method described in Modern Statistics for Modern Biology by Susan Holmes and Wolfgang Huber http://web.stanford.edu/class/bios221/book/Chap-Clustering.html and is excerpted below.  

Taking the logarithm of the within-sum-of-squares (log(WSSk)) and comparing it to averages from simulated data with less structure can be a good way of choosing k. This is the basic idea of the gap statistic introduced by Tibshirani, Walther, and Hastie (2001). We compute log(WSSk) for a range of values of k, the number of clusters, and compare it to that obtained on reference data of similar dimensions with various possible ‘non-clustered’ distributions. We can use uniformly distributed data as we did above or data simulated with the same covariance structure as our original data.

The default choice for the number of clusters, k1, is the first value of k for which the gap is not larger than the first local maximum minus a standard error (see the manual page of the clusGap function). ... the choice recommended by Tibshirani, Walther, and Hastie (2001) is the smallest k such that gap(k)≥gap(k+1)−s′k+1...

The first local maximum is k = 7 and the second one is k = 13. This analysis is choosing to use k = `r clust_num` which is is the first value where the gap value minus its standard error is less than this local maximum at 13.  


<bksp>

<bksp>

###

