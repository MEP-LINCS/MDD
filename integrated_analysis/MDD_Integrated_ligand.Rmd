---
title: "MDD integrated data analysis by ligand"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache=FALSE, cache.lazy = FALSE, message=FALSE, warning = FALSE, fig.height=10, fig.width=12)

suppressMessages(library(tidyverse))
#library(iheatmapr)
#library(pheatmap)
library(ComplexHeatmap)
library(circlize)
library(umap)
library(cluster)
#library(plotly)
library(RColorBrewer)
library(writexl)

source("../R/MDD_functions.R")
create_pdfs <- FALSE
write_csvs <- FALSE

```



```{r read_data_and_metadata}
data_path <- "Data/selected_assay_pk_data_rr.rda"
if(!file.exists(data_path)) stop("cannot load ",data_path)
load(data_path)

#Load migration distances
migration_dist <- read_csv("Data/MDD_migration_distance_lineage_T0.csv") %>%
  filter(thour == 48) %>%
  rename(ligand = treatment,
         experimentalTimePoint = thour,
         value = lineage_length_mean) %>%
  mutate(Type = "live",
         feature = "migration_distance_live",
         ligand = str_remove(ligand, "[+]EGF")) %>%
  rrscale_assay()

selected_assay_pk_data_rr <-selected_assay_pk_data_rr %>%
  bind_rows(migration_dist)
  
feature_gene <- read_csv("Data/MDD_Integrated_feature_gene.csv")

ifng_cluster_features <- readxl::read_excel("Data/MDD_ligand_ifng_cluster_features_UMAP_HIGHLIGHTS.xlsx",col_names = FALSE, sheet = "2") %>%
  rename("feature" = "...1") %>%
  select(feature)

clust_num <- 12
cluster_method <- "kmeans"
ligand_order <-  c("PBS", "HGF", "OSM", "EGF","BMP2+EGF", "IFNG+EGF", "TGFB+EGF")
ligand_cols <- c("CTRL" = "#7A4A2A",
                 "PBS" = "#8dd3c7",
                 "HGF" = "#80b1d3",
                 "OSM" = "#fdb462",
                 "EGF" = "#fb8072",
                 "BMP2+EGF" = "#b3de69",
                 "IFNG+EGF" = "#bebada",
                 "TGFB+EGF" = "#ffd92f")
```

## {.tabset .tabset-fade}

### heatmap

```{r Heatmaps, fig.height = 8}

df_p <- selected_assay_pk_data_rr %>%
  mutate(feature = paste0(feature, "_", experimentalTimePoint),
         Type = str_replace(Type, "motifs", "motif"),
         ligand = str_replace(ligand, "ctrl", "CTRL")) %>%
  filter(!ligand == "CTRL",
         str_detect(Type,"Hallmark|pathway", negate = TRUE)) %>%
  pivot_wider(names_from = ligand) %>%
  dplyr::rename("BMP2+EGF" = "BMP2",
         "IFNG+EGF" = "IFNG",
         "TGFB+EGF" = "TGFB") %>%
  dplyr::select(all_of(ligand_order), everything())


#setup for common cluster colors used in heatmap and ggplot
cluster_cols <- structure(RColorBrewer::brewer.pal(12, "Paired")[c(1:9, 12, 11, 10)],
                          names = 1:clust_num)
#cluster_cols[13] <- "slategrey"
assay_cols <- structure(RColorBrewer::brewer.pal(8, "Paired")[c(6, 2:3,5, 1, 7,8)],
                        names = unique(df_p$Type))
# assay_cols <- structure(RColorBrewer::brewer.pal(length(unique(df_p$Type)), "Paired")[c(6, 2:5, 1, 7:8)],
                        # names = unique(df_p$Type))

# Filter and order to this set of ligands: c("PBS", "HGF", "OSM", "EGF","BMP2", "IFNG", "TGFB")
# median summarize features that have multiple readings sych as motifs
# z scale across rows
df_p_as_matrix <- df_p %>%
  select(all_of(ligand_order)) %>%
  as.matrix() %>%
  t %>%
  scale() %>%
  t
rownames(df_p_as_matrix) <- df_p$feature
df_p_as_matrix <- df_p_as_matrix[order(rownames(df_p_as_matrix)),]

#seed the kmeans clustering with a fixed, random set of points
set.seed(42)
centers <- df_p_as_matrix[sample(1:nrow(df_p_as_matrix), size = clust_num, replace = FALSE),]
clusters <- kmeans(x = df_p_as_matrix, iter.max = 20, centers = centers)$cluster
hm_data <-tibble(feature = names(clusters),
                 Cluster = clusters) %>%
  mutate(Time = str_remove(feature, ".*_"),
         Time = as.numeric(Time),
         Type = str_remove(feature, "_[[:digit:]]*$"),
         Type = str_remove(Type, ".*_"))  %>%
  mutate(feature_sub = str_remove(feature,"_{1}[[:digit:]]*$")) %>%
  left_join(feature_gene, by = c("feature_sub" = "feature")) %>%
  dplyr::select(-feature_sub)

#Recombine data and annotations
hm_data_ann<- cbind(df_p_as_matrix, hm_data)

chm_ann <- hm_data %>%
  select(Cluster, Time, Type) %>%
  mutate(Cluster = factor(Cluster, levels = 1:clust_num, ordered = TRUE),
         Time = factor(Time, levels = c(1,4,8,24,48), ordered = TRUE)) %>%
  as.data.frame()

haRow <- HeatmapAnnotation(df = chm_ann,
                           which = "row",
                           col = list(Type = assay_cols,
                                      Time = c("1" = "azure1",
                                               "4" = "azure2",
                                               "8" = "azure3",
                                               "24" = "azure4",
                                               "48" = "black"),
                                      Cluster = factor(cluster_cols, levels = cluster_cols, ordered = TRUE)))
chm <- Heatmap(df_p_as_matrix,
               name = "Z score",
               column_title = "Selected assay data, rrscaled, z-scaled",
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
               #col = colorRampPalette(rev(brewer.pal(n = 7, name ="RdBu")))(100),
               cluster_rows = FALSE,
               cluster_row_slices = TRUE, 
               cluster_columns = FALSE,
               row_split = hm_data$Cluster,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = FALSE,
               row_names_gp = gpar(fontsize = 8),
               column_names_gp = gpar(fontsize = 10),
               use_raster = FALSE,
               left_annotation = haRow)
chm
if(create_pdfs){
  pdf("MDD_ligands_heatmap_main_CHM_no_pathways.pdf") 
  draw(chm)
  res <- dev.off()
} 


#Calculate and display the correlations between the clusters
#method: calculate the average value of the responses from each ligand within each cluster
# this yields a matrix that is 12 columns with 7 rows
# calculate the correlations betweeen the columns to yield a 12x12 matrix of the correlations

df_cl <- hm_data_ann %>%
  select(-Time) %>%
  group_by(Cluster) %>%
  summarise_if(is.numeric, .funs = mean)%>%
ungroup() %>%
  #mutate(Cluster = paste0("Cl_",Cluster)) %>%
  pivot_longer(cols = -Cluster) %>%
  pivot_wider(names_from = Cluster)

df_cl_as_matrix <- df_cl %>%
  select(-name) %>%
  as.matrix 
rownames(df_cl_as_matrix) <- df_cl$name

df_cl_cors <- cor(df_cl_as_matrix)

chm <- Heatmap(df_cl_cors,
               name = "Z score",
               column_title = "MDD Integrated ligand cluster correlations",
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-1, 0, 1), c("#2166AC", "white", "#B2182B")),
               cluster_rows = TRUE,
               cluster_row_slices = FALSE, 
               cluster_columns = TRUE,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = TRUE,
               row_names_gp = gpar(fontsize = 10),
               column_names_gp = gpar(fontsize = 10),
               column_names_rot = 0,
               use_raster = FALSE)
draw(chm)

if(create_pdfs) {
  pdf("MDD_ligand_heatmap_cluster_correlations.pdf")
  draw(chm)
  res <- dev.off()
} 


df_cl_cors <- cor(df_p_as_matrix)

chm <- Heatmap(df_cl_cors,
               name = "Correlation",
               column_title = "MDD Integrated ligand correlations",
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-1, 0, 1), c("#2166AC", "white", "#B2182B")),
               cluster_rows = TRUE,
               cluster_row_slices = FALSE, 
               cluster_columns = TRUE,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = TRUE,
               row_names_gp = gpar(fontsize = 10),
               column_names_gp = gpar(fontsize = 10),
               column_names_rot = 90,
               use_raster = FALSE)
draw(chm)

if(create_pdfs) {
  pdf("MDD_ligand_heatmap_ligand_correlations.pdf", width = 5, height = 4)
  draw(chm)
  res <- dev.off()
} 

#Create heatmap subsets
subset_rows_module_4 <- hm_data_ann %>%
  filter(Cluster == 4) %>%
  top_n(n = 10, wt = feature)

df_p_as_matrix_subset_4 <- df_p_as_matrix[rownames(df_p_as_matrix) %in% subset_rows_module_4$feature,]

subset_rows_module_8 <- hm_data_ann %>%
  filter(Cluster == 8) %>%
  top_n(n = 10, wt = feature)

df_p_as_matrix_subset_8 <- df_p_as_matrix[rownames(df_p_as_matrix) %in% subset_rows_module_8$feature,]

chm <- Heatmap(df_p_as_matrix_subset_4,
               name = "Z score",
               column_title = "Module 4 subset",
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
               #col = colorRampPalette(rev(brewer.pal(n = 7, name ="RdBu")))(100),
               cluster_rows = FALSE,
               cluster_row_slices = TRUE, 
               cluster_columns = FALSE,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = TRUE,
               row_names_gp = gpar(fontsize = 8),
               column_names_gp = gpar(fontsize = 10),
               use_raster = FALSE)
draw(chm)
if(create_pdfs) {
  pdf("MDD_ligand_heatmap_module_4_subset.pdf", width = 4, height = 3)
  draw(chm)
  res <- dev.off()
} 

#create a figure of the average response of each treatment  in each module
for(ligand in ligand_order){
  df <- hm_data_ann %>%
    select(ligand, "Cluster") %>%
    rename(treatment = ligand) %>%
    group_by(Cluster) %>%
    summarise(response = mean(treatment)) %>%
    ungroup()
  ligand_col <- ligand_cols[names(ligand_cols) == ligand]
  
  p <- ggplot(df, aes(x = Cluster, y = response)) +
    geom_col(fill = ligand_col) +
    coord_cartesian(ylim = c(-2,2))+
    scale_x_continuous(breaks = 1:12) +
    labs(x = "Cluster",
         fill = "response") +
    theme_bw()+
    theme(panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
    )
  p
  
  if(create_pdfs){
    pdf(paste0("MDD_ligands_",ligand,"_cluster_mean.pdf"))
    print(p)
    res <- dev.off()
  }
}

### make a bar plot of module 3 enrichments for each of the ligands? 
### Color code the bars based on the ligand.


#make a faceted version of the mean cluster values by ligand
df <- hm_data_ann %>%
  select(all_of(ligand_order), "Cluster") %>%
  pivot_longer(cols = -Cluster,names_to = "ligand") %>%
  group_by(Cluster, ligand) %>%
  summarise(response = mean(value)) %>%
  ungroup()

p <- ggplot(df, aes(x = Cluster, y = response, fill = factor(Cluster))) +
  geom_col() +
  coord_flip()+
  scale_fill_manual(values = cluster_cols) +
  #coord_cartesian(ylim = c(-2,2))+
  scale_x_continuous(breaks = 1:12) +
  labs(x = "cluster",
       y = "response",
       fill = "Cluster") +
  guides(fill = FALSE) +
  theme_bw()+
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        strip.background = element_blank()
  ) +
  facet_wrap(~ligand, nrow = 1)
p

if(create_pdfs){
  pdf(paste0("MDD_ligands_cluster_means.pdf"), height = 4)
  print(p)
  res <- dev.off()
}

#mean cluster value by ligand
df <- hm_data_ann %>%
  select(all_of(ligand_order), "Cluster") %>%
  filter(Cluster == 3) %>%
  pivot_longer(cols = -Cluster,names_to = "ligand") %>%
  group_by(Cluster, ligand) %>%
  summarise(response = mean(value)) %>%
  ungroup() %>%
  mutate(ligand = factor(ligand, levels = ligand_order))
  

  p <- ggplot(df, aes(x = ligand, y = response, fill = ligand)) +
    geom_col() +
    scale_fill_manual(values = ligand_cols) +
    labs(x = "ligand") +
    guides(fill = FALSE) +
    theme_bw()+
    theme(panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.text.x = element_text(angle = 90)
    )
  p

if(create_pdfs){
  pdf(paste0("MDD_ligands_cluster_3_means.pdf"), width = 4, height = 4)
  print(p)
  res <- dev.off()
}
  
#enrichment analysis
RNAseq_genes <- read_csv("Data/MDD_RNAseq_DEGenesLong.csv")
lfc_thresh <- 1.5
padj_thresh <- .05
for(l in ligand_order){
  ligand <- str_remove(l, "[+].*")
  df <- RNAseq_genes %>%
  filter(str_detect(experimentalCondition, ligand),
         abs(log2FoldChange) > lfc_thresh,
         padj < padj_thresh) %>%
   mutate(direction = if_else(log2FoldChange < 0 ,"down", "up"))
res <- write_csv(df, paste0("MDD_integrated_ligand_up_down_genes_",ligand,".csv"))
up_symbols <- df %>%
  filter(direction == "up") %>%
  pull(hgnc_symbol)
res <- write.csv(up_symbols, paste0("MDD_integrated_ligand_up_genes_",ligand,".csv"),
                 row.names = FALSE,
                 quote = FALSE,
                 col.names = FALSE)
down_symbols <- df %>%
  filter(direction == "down") %>%
  pull(hgnc_symbol)
res <- write.csv(down_symbols, paste0("MDD_integrated_ligand_down_genes_",ligand,".csv"),
                 row.names = FALSE,
                 quote = FALSE,
                 col.names = FALSE)
}

```

Main heatmap shows selected data, rrscaled then scaled across each row. Time 0 values are removed since the columns are ligands and the only "ligand" measured at time 0 was CTRL. There are `r dim(df_p_as_matrix)[1]` rows in the heatmap whith a stucture of feature_assay_time. 
```{r writeModulePDFs}

#identify plsr features in each module
plsr_features <- read_csv(file = "Data/RPPA_PLSR_DNA2n_top_vips.csv")

plsr_rppa_features <- plsr_features %>%
  mutate(feature = paste0(feature, "_RPPA"))
  
hm_data_ann_plsr <- hm_data_ann %>%
  filter(Time %in% c(24, 48)) %>%
  mutate(analyte_assay = str_remove(feature, "_[248]*$"),
         plsr_rppa_feature = analyte_assay %in% plsr_rppa_features$feature,
         plsr = "No")
hm_data_ann_plsr$plsr[hm_data_ann_plsr$plsr_rppa_feature] <- "Yes"

#count the number of plsr features in each module
plsr_module_count <- hm_data_ann_plsr %>%
  filter(plsr_rppa_feature) %>%
  group_by(Cluster) %>%
  count() %>%
  ungroup() %>%
  rename(Module = Cluster)
write_csv(plsr_module_count, "MDD_integrated_plsr_module_count.csv")

#Write out pdfs of each module with row names
if(create_pdfs){
  res <- lapply(1:clust_num, function(cl_select){

  #Create heatmap subsets
selected_module <- hm_data_ann_plsr %>%
  filter(Cluster == cl_select)
  
df_p_as_matrix_selected <- df_p_as_matrix[rownames(df_p_as_matrix) %in% selected_module$feature,]
plsr_cols <- c("black", "white")
names(plsr_cols) <- c("Yes", "No")

  row_annot <- rowAnnotation(df = data.frame(plsr_rppa_feature = selected_module$plsr_rppa_feature),
                name = "Type")

chm <- Heatmap(df_p_as_matrix_selected,
               name = "Z score",
               column_title = paste0("Module ",cl_select),
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
               #col = colorRampPalette(rev(brewer.pal(n = 7, name ="RdBu")))(100),
               cluster_rows = TRUE,
               cluster_row_slices = TRUE, 
               km = 10,
               cluster_columns = FALSE,
               right_annotation = row_annot,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = TRUE,
               row_names_gp = gpar(fontsize = 1.5),
               column_names_gp = gpar(fontsize = 10),
               use_raster = FALSE)

pdf(file = paste0("MDD_integrated_ligand_module_",cl_select,".pdf"),
    height = 30, width = 4)
draw(chm)
res <- dev.off()
  })
}


```

```{r, eval = TRUE}
selectFeature <- function(df){
  #browser()
  res <- df %>%
    select(feature, Type, Time, symbol) %>%
    mutate(analyte = str_remove(feature, "_.*")) %>%
    rename(assay = Type,
           time = Time) %>%
    select(feature, analyte, assay, time, symbol)
return(res)
}

selectDerivedFeature <- function(df){
  #browser()
  res <- df %>%
    select(feature, FDR, Type)
return(res)
}

module_features <- hm_data_ann %>%
  select(feature, Cluster, Type, Time, symbol) %>%
  #bind_rows(reactome_pathways) %>%
  arrange(Cluster, Type) %>%
  mutate(Cluster = paste0("module_", Cluster),
         Cluster = factor(Cluster, levels = unique(Cluster))) %>%
  split(.$Cluster) %>%
   map(selectFeature)

res <- write_xlsx(module_features,
                  path = "MDD_ligand_module_features.xlsx")

fdr_cutoff <- .2
reactome_pathways <-  read_csv("Data/MDD_Integrated_ligand_reactome_clusters.csv") %>%
  mutate(Cluster = str_remove(Cluster, ".*_"),
         Cluster = as.numeric(Cluster),
         Type = "Reactome_pathway") %>%
  rename(feature = Description,
         FDR = qvalue) %>%
  select(Cluster, FDR, feature, Type) %>%
  filter(FDR < fdr_cutoff)

chea3_features <- read_csv("Data/MDD_Clusters_CHEA3_Remap.csv") %>%
  janitor::clean_names() %>%
  rename(Cluster = query_name,
         feature = tf,
         FDR = fdr) %>%
  mutate(Cluster = str_remove(Cluster, ".*_"),
         Cluster = as.numeric(Cluster),
         Type = "ChEA3") %>%
  select(Cluster, FDR, feature, Type) %>%
  filter(FDR < fdr_cutoff)

hallmark_enrichments <- read_csv("Data/MDD_Module_HallmarkEnrichments.csv") %>%
  rename(Cluster = Module,
         feature = gene_set) %>%
  mutate(Cluster = str_remove(Cluster, "cluster_"),
         Cluster = as.numeric(Cluster),
         Type = "Hallmark") %>%
  select(Cluster, FDR, feature, Type) %>%
  filter(FDR < fdr_cutoff)

module_derived_features <-reactome_pathways %>%
  bind_rows(chea3_features) %>%
  bind_rows(hallmark_enrichments) %>%
  mutate(Cluster = paste0("module_", Cluster),
    Cluster = factor(Cluster, levels = paste0("module_",1:12), ordered = TRUE)) %>%
    arrange(Cluster, FDR) %>%
  split(.$Cluster) %>%
   map(selectDerivedFeature)

res <- write_xlsx(module_derived_features,
                  path = "MDD_ligand_module_derived_features.xlsx")

if(write_csvs){
  res <- lapply(1:clust_num, function(cl_select){
    df_p_sp_sel <- hm_data_ann %>%
      filter(Cluster == cl_select) %>%
      write_csv(paste0("Tables/Ligand_clusters/MDD_ligand_cluster_",cl_select,"_features.csv"),col_names = TRUE)
  })
}

```



```{r, eval = FALSE}
df_a <- df_p_sp %>%
  arrange(Cluster, feature)

df <- df_a %>%
  select(-Cluster, -Type, -symbol)

df_cl <- df_a %>%
  select(feature, Cluster)

dfm <- df %>%
  select(-feature) %>%
  t
colnames(dfm) <- df$feature

df_cor <- dfm %>%
  cor %>%
  signif(2) %>%
  as_tibble(rownames = "feature") %>%
  left_join(df_cl, by = "feature") %>%
  select(feature, Cluster, everything())
    if(write_csvs) write_csv(df_cor, paste0("Tables/MDD_Ligand_correlations_",clust_num,".csv"))

```

###

### PCA    

```{r PCAAnalysis}

pca_obj <- prcomp(df_p_as_matrix,scale. = FALSE)
plot(pca_obj)

pca_df <- as_tibble(pca_obj$x) %>%
  mutate(feature = rownames(pca_obj$x),
         Time = str_remove(feature,".*_"),
         Time = as.integer(Time),
         Type = str_extract(feature,"_(RNA|RPPA|cycIF|ATAC|GCP|IF|motif)_"),
         Type = str_remove_all(Type, "_")) %>%
  left_join(hm_data_ann, by = c("feature", "Type", "Time")) %>%
  mutate(feature = str_remove(feature, "_.*"))


pca_diagnostics_df <- as_tibble(pca_obj$rotation) %>%
  mutate(ligand = rownames(pca_obj$rotation)) %>%
  select(-PC7)

#make a heatmap of the rotated data
pca_matrix <- pca_obj$x %>%
  as.matrix()
# pca_hm <- get_iheatmap(pca_matrix, assay_name = "PCA rotated values") %>%
#   format_hm(k = clust_num,
#             cluster_method = cluster_method,
#             colors = cluster_cols,
#             type_colors = assay_cols,
#             groups = cluster_groups)
# pca_hm

```

```{r pcaFigures, eval = TRUE}

p <- ggplot(pca_df, aes(x = PC1, y = PC2, colour = factor(Time))) +
  geom_point(alpha = .5)
p

p <- ggplot(pca_df, aes(x = PC3, y = PC4, colour = factor(Time))) +
  geom_point(alpha = .5)
p

p <- ggplot(pca_df, aes(x = PC1, y = PC2, colour = factor(Type))) +
  geom_point(alpha = .5)
p

p <- ggplot(pca_df, aes(x = PC3, y = PC4, colour = factor(Type))) +
  geom_point(alpha = .5)
p

p <- ggplot(pca_df, aes(x = PC5, y = PC6, colour = factor(Time))) +
  geom_point(alpha = .5)
p

p <- ggplot(pca_df, aes(x = PC1, y = PC2, colour = factor(Cluster))) +
  geom_point(alpha = .5)
p

p <- ggplot(pca_df, aes(x = PC3, y = PC4, colour = factor(Cluster))) +
  geom_point(alpha = .5)
p

p <- ggplot(pca_df, aes(x = PC5, y = PC6, colour = factor(Cluster))) +
  geom_point(alpha = .5)
p


df <- pca_diagnostics_df %>%
  gather(PC, value, -ligand)

p <- ggplot(df, aes(x = PC, y = value, fill = ligand)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = ligand_cols)
p

p <- ggplot(df, aes(x = ligand, y = value, fill = PC)) +
  geom_bar(stat = "identity", position = "dodge")
p

df_IFNG <- df %>%
  filter(ligand == "IFNG+EGF")

p <- ggplot(df_IFNG, aes(x = PC, y = value, fill = ligand)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = ligand_cols) +
  theme_bw()
p

```


###


### UMAPs

```{r UMAPAnalysis, fig.width=5.75, fig.height=4.75}

#Generate a 2d scatterplot of the UMAP dimensions and color by clusters, assay type

#Create annotation values
hm_data_matrix <- hm_data_ann %>%
  dplyr::select(-feature, -Cluster, -Type, -Time, -symbol) %>%
  as.matrix()
rownames(hm_data_matrix) <- hm_data_ann$feature

custom_settings = umap.defaults
custom_settings$random_state <- 42
custom_settings$n_epochs = 200
custom_settings$n_neighbors = 15

df_UMAP <- umap(hm_data_matrix, config = custom_settings, na.rm = TRUE)$layout %>%
  data.frame(feature = rownames(hm_data_matrix)) %>%
  rename(UMAP_1 = X1,
         UMAP_2 = X2) %>%
  left_join(hm_data_ann, by = "feature") 

plot_UMAP_3d <- FALSE
if(plot_UMAP_3d){
  custom_settings$n_components = 3
  
  df_UMAP_3d <-  umap(hm_data_matrix, config = custom_settings, na.rm = TRUE)$layout %>%
    data.frame(feature = rownames(hm_data_matrix)) %>%
    rename(UMAP_1 = X1,
           UMAP_2 = X2,
           UMAP_3 = X3) %>%
    left_join(hm_data_ann, by = "feature")
  df_UMAP_3d$Cluster_color <- cluster_cols[df_UMAP_3d$Cluster]
  save(df_UMAP_3d, file = "MDD_UMAP_3d")
  
  library(rgl)
  plot3d(df_UMAP_3d$UMAP_1,
         df_UMAP_3d$UMAP_2,
         df_UMAP_3d$UMAP_3,
         col = factor(df_UMAP_3d$Cluster_color))
}

  p <- ggplot(df_UMAP, aes(x = UMAP_1,
                           y = UMAP_2,
                           colour = factor(Cluster))) +
    geom_point(size = 1, alpha = .6, shape = 16) +
    scale_color_manual(values = cluster_cols) +
    labs(title = paste("UMAP embedding colored by cluster"),
         colour = "Cluster") +
    guides(colour = guide_legend(override.aes = list(alpha = 1, size = 4))) +
    theme_bw()+
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line =element_blank())
  p
  
  if(create_pdfs) {
    pdf("MDD_ligands_umap_main.pdf")    
    print(p)
    res <- dev.off()
  } 
```

There are `r dim(hm_data_matrix)[1]` dots in the 2d UMAP. These represent the `r dim(hm_data_matrix)` ligand values that have been rrscaled within each assay and then z-scaled within each set of 7 feature_assay_time values.  

```{r UMAPAnalysis2, fig.width=7.5, fig.height=4}
p <- ggplot(data = df_UMAP[df_UMAP$Type=="RNA",], aes(x = UMAP_1,
                                                      y = UMAP_2,
                                                      colour = factor(Type))) +
  geom_point(size = .8, alpha = .6) +
  scale_colour_manual(values = assay_cols)+
  labs(title = paste("UMAP embedding colored by assay"),
       colour = "Assay") +
  guides(colour = guide_legend(override.aes = list(alpha = 1, size = 4))) +
  theme_bw()+
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line =element_blank())
p <- p + geom_point(data = df_UMAP[!df_UMAP$Type=="RNA",],size = .8, alpha = .8)
p

if(create_pdfs) {
  pdf("MDD_ligands_umap_type.pdf") 
      print(p)
  res <- dev.off()
}

```

```{r highlightAssay, fig.width=2.5, fig.height=2.5}

if(create_pdfs) {
  pdf("MDD_ligands_umap_type_highlights.pdf") 
  # for(assay in unique(df_p$Type)){
  #   regex_pat <- paste0("^",assay,"$")
  #   df <- df_UMAP %>%
  #     mutate(Highlight = str_extract(Type, regex_pat),
  #            Highlight = str_replace_na(Highlight),
  #            Highlight = str_replace(Highlight, "^NA$", ".1"),
  #            Highlight = str_replace(Highlight, assay, "1"),
  #            Highlight = as.numeric(Highlight))
  #   
  #   p <- ggplot(data = df[!df$Highlight==1,], aes(x = UMAP_1,
  #                       y = UMAP_2)) +
  #     geom_point(colour = "grey", size = 2, alpha = .4, shape = 16) +
  #     annotate("text",x = -2, y = -6, label = assay)+
  #     scale_size_area(limits = c(0, 30)) +
  #     labs()+
  #     guides(colour = FALSE,
  #            size = FALSE)+
  #     theme_bw()+
  #     theme(axis.title = element_blank(),
  #           axis.text = element_blank(),
  #           axis.ticks = element_blank(),
  #           panel.border = element_blank(),
  #           panel.grid.major = element_blank(),
  #           panel.grid.minor = element_blank(),
  #           axis.line =element_blank())
  #    p <- p + geom_point(data = df[df$Highlight==1,],
  #                        color =  "slateblue1",
  #                        size = 2,
  #                        alpha = .8,
  #                        shape = 16)
  #   print(p)
  # }
  for(assay in unique(df_p$Type)){
    df <- df_UMAP
    
    p <- ggplot(data = df[!df$Type==assay,], 
                aes(x = UMAP_1,
                    y = UMAP_2,
                    color = Type)) +
      geom_point(color = "gray",size = 1, alpha = .4, shape = 16) +
      scale_colour_manual(values = assay_cols) +
      annotate("text",x = -2, y = -6, label = assay) +
      # scale_color_manual(values=c("grey", "slateblue1"))+
      scale_size_area(limits = c(0, 30)) +
      labs()+
      guides(colour = FALSE,
             size = FALSE)+
      theme_bw()+
      theme(axis.title = element_blank(),
            axis.text = element_blank(),
            axis.ticks = element_blank(),
            panel.border = element_blank(),
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            axis.line =element_blank())
    p <- p + geom_point(data = df[df$Type==assay,], 
                        size = 1,
                        alpha = .9,
                        shape = 16) 
    print(p)
  }
}

  res <- dev.off()
```


```{r highlightGeneSet, fig.width=2.5, fig.height=2.5, eval = FALSE}

for(gene_set in c("Hallmark_E2F_Targets", "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION")){
  df_gene_set <- read_tsv(paste0("RNAseq/Data/",gene_set,"_geneset.txt"),skip=2, col_names = FALSE,
                          col_types = cols(X1 = col_character())) %>%
    rename(symbol = X1) %>%
    mutate(gene_set = gene_set) %>%
    right_join(df_UMAP, by = "symbol",fill = "") %>%
    drop_na()
  
  p <- ggplot(df_UMAP, aes(x = UMAP_1,
                           y = UMAP_2)) +
    geom_point(size = .1, colour = "gray", alpha = .6) +
    annotate("text",x = -1, y = -6, label = gene_set, size = 1) +
    labs()+
    guides(colour = FALSE,
           size = FALSE) +
    theme_bw() +
    theme(axis.title = element_blank(),
          panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(colour = "black"))
  
  p <- p + geom_point(data = df_gene_set, size = 1, colour = "black", alpha = .4)
  
  
  p <- ggplot(df_UMAP, aes(x = UMAP_1,
                           y = UMAP_2,
                           colour = factor(Cluster))) +
    geom_point(size = .1, alpha = .6) +
    annotate("text",x = -1, y = -6, label = gene_set, size = 1.5) +
    labs()+
    guides(colour = FALSE,
           size = FALSE)+
    theme(axis.title = element_blank())
  p <- p + geom_point(data = df_gene_set, size = 1, colour = "black", alpha = .6)+
    theme_bw()
  print(p)
}


```

```{r UMAPbyCondition, fig.width=2.5, fig.height=2.5}
if(create_pdfs) pdf("MDD_ligands_umap_by_ligand.pdf")

df <- df_UMAP %>%
  rename("BMP2_EGF" = "BMP2+EGF",
         "IFNG_EGF" =  "IFNG+EGF",
         "TGFB_EGF" = "TGFB+EGF")
df_UMAP_ligands <- colnames(df)[str_detect(colnames(df_UMAP),"PBS|HGF|OSM|EGF|BMP2|IFNG|TGFB")] %>%
  str_replace("[+]","_")
for(ligand in df_UMAP_ligands){
  p <- ggplot(df, aes_string(x = "UMAP_1",
                                  y = "UMAP_2",
                                  colour = ligand)) +
    geom_point(size = 1.5, alpha = .8, shape = 16) +
    annotate("text",x = -2, y = -6, label = ligand)+
    #colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100)
    #scale_color_gradient2(low = "blue4", mid = "azure", high = "red", midpoint = 0,) +
    scale_color_gradientn(colours = colorRampPalette(rev(brewer.pal(n = 7, name =
                                                                      "RdBu")))(100)) +
    labs()+
    guides(colour = FALSE)+
    theme_bw()+
    theme(text = element_text(size = 1),
          axis.title = element_blank(),
          panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(colour = "black"))
  print(p)
}
  res <- dev.off()

```


```{r CellCycleHeatmap, fig.width=2.5, fig.height=2.5}

load("Data/assay_pk_data.rda")
#heatmap of selected cluster 3 conditions

condition_levels <- paste(rep(ligand_order, each = 2), c(24, 48), sep= "_") %>%
  c("CTRL_0", .)

cc_features <- readxl::read_excel("Data/HEATMAP_CELLCYCLE.xlsx", 
                                  col_names = TRUE) %>%
  #filter(str_detect(feature,"0|24|48")) %>%
  mutate(feature = str_remove(feature,"_[[:digit:]]*$")) %>%
  select(feature) %>%
  distinct() %>%
  drop_na()

cc_selected <- assay_pk_data %>%
  filter(str_detect(experimentalTimePoint, "0|24|48" )) %>%
  right_join(cc_features, by = "feature") %>%
  mutate(ligand = str_replace(ligand, "BMP2", "BMP2+EGF"),
         ligand = str_replace(ligand, "TGFB", "TGFB+EGF"),
         ligand = str_replace(ligand, "IFNG", "IFNG+EGF"),
         ligand = str_replace(ligand, "ctrl", "CTRL"),
         condition = paste(ligand, experimentalTimePoint, sep = "_")) %>%
  select(feature, value, condition) %>%
  pivot_wider(names_from = condition, values_from = value) %>%
  select(feature, condition_levels)

cc_dm <- cc_selected %>%
  select(-feature) %>%
  as.matrix() %>%
  t() %>%
  scale() %>%
  t()
rownames(cc_dm) <- cc_selected$feature

hm <- Heatmap(cc_dm,
              name = "Z score",
              column_title = "Cell cycle features",
              col = colorRampPalette(rev(brewer.pal(n = 7, name ="RdBu")))(100),
              cluster_rows = TRUE,
              cluster_row_slices = FALSE,
              cluster_columns = FALSE,
              split = c(rep(1,2),rep(2,12),rep(3,6),rep(4,10),rep(5,2)),
              row_gap = unit(2, "mm"),
              row_title = " ",
              row_names_gp = gpar(fontsize = 8),
              column_names_gp = gpar(fontsize = 10),
)

if(create_pdfs){
  pdf("MDD_ligands_cell_cycle_heatmap.pdf")
  hm
}

```


```{r UMAPCellCycle_vip, fig.width=2.5, fig.height=2.5}
# 
# regex_pattern <- paste(cell_cycle_plsr_features$feature,  collapse = "|")
# df <- df_UMAP %>%
#   mutate(
#     Highlight = case_when(
#       str_detect(feature, regex_pattern) ~ 1,
#       # Cluster == 8 ~ 1,
#       TRUE ~ 0
#     )
#   )
# 
#   p <- ggplot(data = df[!df$Highlight == 1,], aes(x = UMAP_1,
#                       y = UMAP_2,
#                       colour = factor(Highlight)
#                       )) +
#     geom_point(alpha = .6, shape = 16, size = 1) +
#     scale_color_manual(values = c("0" = "grey", "1" = "#FF7F00"))+
#     labs()+
#     guides(colour = FALSE,
#            size = FALSE)+
#     theme_bw()+
#     theme(axis.title = element_blank(),
#           axis.text = element_blank(),
#           axis.ticks = element_blank(),
#           panel.border = element_blank(),
#            panel.grid.major = element_blank(),
#            panel.grid.minor = element_blank(),
#            axis.line =element_blank())
#   p <- p + geom_point(data = df[df$Highlight == 1,], size = 1, alpha = .8, shape = 16)
# p
# 
# 
# if(create_pdfs){
#   pdf("MDD_ligands_umap_dna2n_vip.pdf")
#   p
# }
# 
    if(write_csvs) write_csv(df, "MDD_ligand_dna2n_vip_umap.csv")

```


```{r UMAP_IFNG_Cluster, fig.width=2.5, fig.height=2.5, eva = FALSE}

df <- df_UMAP %>%
  mutate(
    Highlight = case_when(
      feature %in% ifng_cluster_features$feature ~ 2,
      Cluster == 12 ~ 1,
      TRUE ~ 0
    )
  )

p <- ggplot(data = df[!df$Highlight == 2,], 
            aes(x = UMAP_1,
                y = UMAP_2,
                colour = factor(Highlight),
                label = feature
            )) +
  geom_point(alpha = .6, shape = 16, size = 1) +
  scale_color_manual(values = c("0" = "grey", "1" =  "#6A3D9A", "2" = "darkorange1"))+
  labs()+
  guides(colour = FALSE,
         size = FALSE)+
  theme_bw()+
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line =element_blank())
p <- p + geom_point(data = df[df$Highlight == 2,], size = 1, alpha = .8, shape = 16)
p <- p + geom_text(data = df[df$Highlight == 2,], size = 2, color = "black")
p

pr <- ggplot(data = df[!df$Highlight == 2,], 
             aes(x = UMAP_1,
                 y = UMAP_2,
                 colour = factor(Highlight),
                 label = feature
             )) +
  geom_point(alpha = .6, shape = 16, size = 1) +
  scale_color_manual(values = c("0" = "grey", "1" =  "#6A3D9A", "2" = "red"))+
  labs()+
  guides(colour = FALSE,
         size = FALSE)+
  theme_bw()+
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line =element_blank())
pr <- pr + geom_point(data = df[df$Highlight == 2,], size = 1, alpha = .8, shape = 16)
pr <- pr + geom_text(data = df[df$Highlight == 2,], size = 2, color = "black")
pr


#   p1 <- ggplot(data = df[!df$Highlight == 2,], aes(x = UMAP_1,
#                      y = UMAP_2,
#                       colour = factor(Highlight),
#                       fill = factor(Highlight),
#                       label = feature
#                       )) +
#     geom_point(alpha = .6, shape = 16, size = 1) +
#     scale_color_manual(values = c("0" = "grey", "1" =  "#6A3D9A", "2" = "cornflowerblue"))+
#     #scale_fill_manual(values = c("0" = "grey", "1" =  "#6A3D9A", "2" = "cornflowerblue"))+
#     labs()+
#     guides(colour = FALSE,
#            fill = FALSE,
#            size = FALSE)+
#     theme_bw()+
#     theme(axis.title = element_blank(),
#           axis.text = element_blank(),
#           axis.ticks = element_blank(),
#           panel.border = element_blank(),
#            panel.grid.major = element_blank(),
#            panel.grid.minor = element_blank(),
#            axis.line =element_blank())
#   p1 <- p1 + geom_point(data = df[df$Highlight == 2,], size = 2, alpha = .8, shape = 21)
#   p1 <- p1 + geom_text(data = df[df$Highlight == 2,], size = 2, color = "black")
# p1

if(create_pdfs){
  pdf("MDD_ligands_umap_ifng_cluster_highlights.pdf")
  print(p)
  print(pr)
  res <- dev.off()
} 

```

###

### method  

This dataset combines MCF10A Molecular Deep Dive (MDD) RNAseq, Reverse Phase Protein Array(RPPA), Global Chromatin Profiling (GCP) histone modifications, immunofluorescence (IF), cyclic immunofluorescence (cycIF) and ATACseq chromatin configuration-identified motif data. Most of the data is median summarized from three replicate experiments run in sequential weeks. It is then rrscale transformed and then zscored by feature_time.   

RRscale  
Use rrscale https://CRAN.R-project.org/package=rrscale to transform features in the heatmap before clustering.  This method performs a box-cox gaussianizing transformation on each feature, zscores the results then eliminates outliers with absolute values greater than `r zscore_cutoff`. All values from each assay were rrscaled as a matrix with features in the columns and conditions in the rows. Because of the differences in scales in the morphology, spatial and statistical values, the features in the  IF datasetare rrscaled individually.      

This analysis is based on the LINCS Molecular Deep Dive data files on Synapse at  https://www.synapse.org/#!Synapse:syn2862345/wiki/588244.  

motif values  
method to be described

cycIF Values  
Select `r length(unique(cycIF_values_rr$feature))` cycIF features based on their biological relevance  
Median summarize the values across the replicates  

GCP Values  
Median summarize the values across the replicates  
Order by variance and remove the bottom 25%.

IF Values  
Use ilastik+CellProfiler and phenotype features

RNAseq Values  
A gene list representative of the largest gene expression changes across all ligand treatments was produced from differential expression analyses of each experimental condition compared to the control condition. For each experimental condition, a differential expression analysis was performed using the R package DESeq2 (1.24.0), with shrunken log2 fold change estimates calculated using the apeglm method. Each list was filtered to include only genes with an adjusted p value < 0.05, then ranked by the absolute value of their log2 fold change estimate. The 100 most differentially expressed genes per condition were selected. Redundant genes were removed.

RPPA Values  
Median summarize the values across the replicates  
Order by variance and remove the bottom 25%.

Clustering  
k-means clustering is used with k = `r clust_num` based on gap statistic analysis.  


```{r featureTypes, fig.width=8, fig.height=4}
#create a bar chart of the feature types
df <- hm_data_ann %>%
  #drop_na() %>%
  select(feature, Type) %>%
  distinct()

p <- ggplot(hm_data_ann, aes(x = Type, fill = Type)) +
  geom_bar() +
  coord_cartesian(ylim = c(0, 10000)) +
  scale_fill_manual(values = assay_cols)+
  labs(title = paste("Type distribution of the",length(unique(paste0(hm_data_ann$feature))), "features at unique timepoints in the MDD integrated dataset"),
       x ="Feature type") +
  theme_bw()+
  theme(#axis.title = element_blank(),
    axis.text.x =  element_text(angle = 90),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())

p

p_log <- ggplot(hm_data_ann, aes(x = Type, fill = Type)) +
  geom_bar() +
  scale_y_log10() +
  scale_fill_manual(values = assay_cols)+
  labs(title = paste("Type distribution of the",length(unique(paste0(hm_data_ann$feature))), "features at unique timepoints in the MDD integrated dataset"),
       x ="Feature type") +
  theme_bw()+
  theme(#axis.title = element_blank(),
    axis.text.x =  element_text(angle = 90),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())

p_log
if(create_pdfs){
  pdf("MDD_ligands_feature_type_distribution.pdf")
  print(p)  
  res <- dev.off()
  pdf("MDD_ligands_feature_type_distribution_log_scale.pdf")
  print(p_log)
  res <- dev.off()
} 

```

###

### cluster analysis

```{r gapStatistics, fig.width=4, fig.height=4, eval = TRUE}
#implement gap statistic analysis


plot_gap_custom <- function(x) {
  gstab = data.frame(x$Tab, k = seq_len(nrow(x$Tab)))
  p <- ggplot(gstab, aes(k, gap)) + 
    geom_line() +
    geom_errorbar(aes(ymax = gap + SE.sim,
                      ymin = gap - SE.sim), width=0.1) +
    geom_point(size = .5, col=  "red") +
    labs(title = paste("Gap analysis to determine cluster number,",cluster_method)) +
     theme_bw()+
  theme(axis.ticks = element_blank(),
        panel.border = element_blank(),
       # panel.grid.major = element_blank(),
        #panel.grid.minor = element_blank(),
        axis.line =element_blank())
  return(p)
}

if(file.exists(paste0("Data/gss_",cluster_method,"_ligand_data.rda"))){
  load(paste0("Data/gss_",cluster_method,"_ligand_data.rda"))
} else {
  gss <- clusGap(df_p_as_matrix, FUN = kmeans, K.max = 15, B = 500, verbose = FALSE)
  save(gss, file = paste0("Data/gss_",cluster_method,"_ligand_data.rda"))
}

  plot_gap_custom(gss)
if(create_pdfs){
  pdf("MDD_ligands_gap_cluster.pdf")
  p <- plot_gap_custom(gss)
  print(p)
  res <- dev.off()
}

p <- ggplot(hm_data_ann, aes(x = as.factor(Cluster), fill = Type)) +
  geom_bar() +
  scale_fill_manual(values = assay_cols)+
  labs(x = "Cluster",
       fill = "Assay") +
  theme_bw()+
  theme(axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line =element_blank())
p
if(create_pdfs){
  pdf("MDD_ligands_assay_cluster.pdf")
  print(p)
  res <- dev.off()
}
```

```{r assayClusterdistribution, fig.width=8, fig.height=4, eval = TRUE}



p <- ggplot(hm_data, aes(x = as.factor(Cluster), fill = Type)) +
  geom_bar(position = "dodge") +  
  scale_fill_manual(values = assay_cols) +
  labs(x = "Cluster",
       fill = "Assay") +
  facet_wrap(~Type, scales = "free_y") +
  theme_bw()+
  theme(#axis.title = element_blank(),
    #axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())
p

if(create_pdfs){
  pdf("MDD_ligands_cluster_feature_counts.pdf")
  print(p)
  res <- dev.off()
} 

```


This analysis can be interpreted to select the number of clusters in the dataset. It is based on a method described in Modern Statistics for Modern Biology by Susan Holmes and Wolfgang Huber http://web.stanford.edu/class/bios221/book/Chap-Clustering.html and is excerpted below.  

Taking the logarithm of the within-sum-of-squares (log(WSSk)) and comparing it to averages from simulated data with less structure can be a good way of choosing k. This is the basic idea of the gap statistic introduced by Tibshirani, Walther, and Hastie (2001). We compute log(WSSk) for a range of values of k, the number of clusters, and compare it to that obtained on reference data of similar dimensions with various possible ‘non-clustered’ distributions. We can use uniformly distributed data as we did above or data simulated with the same covariance structure as our original data.

The default choice for the number of clusters, k1, is the first value of k for which the gap is not larger than the first local maximum minus a standard error (see the manual page of the clusGap function). ... the choice recommended by Tibshirani, Walther, and Hastie (2001) is the smallest k such that gap(k)≥gap(k+1)−s′k+1...

The first local maximum is k = 7 and the second one is k = 13. This analysis is choosing to use k = `r clust_num` which is is the first value where the gap value minus its standard error is less than this local maximum at 13.  


<bksp>

<bksp>

###

