---
title: "MDD integrated data analysis by condition"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache=FALSE, cache.lazy = FALSE, message=FALSE, warning = FALSE, fig.height=10, fig.width=12)

suppressMessages(library(tidyverse))
library(ComplexHeatmap)
library(circlize)
library(umap)
library(cluster)
library(RColorBrewer)
library(writexl)

source("../R/MDD_functions.R")
create_pdfs <- FALSE
write_csvs <- FALSE

```



```{r setup_parameters_and_metadata}
data_path <- "../integrated_analysis/integrated_matrix_lfc_values.csv"

clust_num <- 11
cluster_method <- "kmeans"

experimentalTimePoints <- c("_24", "_48")
ligand_order <-  c("PBS", "HGF", "OSM", "EGF","BMP2+EGF", "IFNG+EGF", "TGFB+EGF")
condition_order <- paste0(rep(ligand_order, each = length(experimentalTimePoints)), rep(c("_24", "_48"), times = length(ligand_order)))
ligand_cols <- c("CTRL" = "#7A4A2A",
                 "PBS" = "#8dd3c7",
                 "HGF" = "#80b1d3",
                 "OSM" = "#fdb462",
                 "EGF" = "#fb8072",
                 "BMP2+EGF" = "#b3de69",
                 "IFNG+EGF" = "#bebada",
                 "TGFB+EGF" = "#ffd92f")

```

```{r prepData}

#Read in the integrated data, add EGF to some names, set order
if(!file.exists(data_path)) stop("cannot read ",data_path)
integrated_T0_DE <- read_csv(data_path) %>%
  pivot_longer(cols = matches("_24|_48"), names_to = "condition") %>%
  mutate(condition = str_replace(condition, "BMP2","BMP2+EGF"),
         condition = str_replace(condition, "IFNG","IFNG+EGF"),
         condition = str_replace(condition, "TGFB","TGFB+EGF")) %>%
  pivot_wider(names_from = condition) %>%
  select(feature, Type, all_of(condition_order)) %>%
  drop_na

#setup for common cluster and assay colors
cluster_cols <- c(structure(RColorBrewer::brewer.pal(12, "Paired")[c(1:12)],
                          names = 1:12), c("13" = "black", "14" = "gray"))

assay_cols <- structure(RColorBrewer::brewer.pal(8, "Paired")[c(6, 2:3,5, 1)],
                        names = unique(integrated_T0_DE$Type))

#Create data and metadata matrices and annotations
#k means cluster and order by cluster value

int_T0_DE_matrix <- integrated_T0_DE %>%
  select(all_of(condition_order)) %>%
  as.matrix() 

rownames(int_T0_DE_matrix) <- integrated_T0_DE$feature
int_T0_DE_matrix <- int_T0_DE_matrix[!is.nan(int_T0_DE_matrix[,1]),]

#seed the kmeans clustering with a fixed, random set of points
set.seed(42)
centers <- int_T0_DE_matrix[sample(1:nrow(int_T0_DE_matrix), size = clust_num, replace = FALSE),]
clusters <- kmeans(x = int_T0_DE_matrix, iter.max = 20, centers = centers)$cluster

integrated_T0_DE<-tibble(feature = names(clusters),
                 Cluster = clusters) %>%
  right_join(integrated_T0_DE, by = "feature") %>%
  arrange(desc(Cluster))

heatmap_ann <- integrated_T0_DE %>%
  select(Cluster, Type) %>%
  mutate(Cluster = factor(Cluster, levels = 1:clust_num, ordered = TRUE)) %>%
  as.data.frame()

haRow <- HeatmapAnnotation(df = heatmap_ann,
                           which = "row",
                           col = list(Cluster = factor(cluster_cols, levels = cluster_cols, ordered = TRUE),
                                      Type = assay_cols))

```
## {.tabset .tabset-fade}

### heatmap

```{r heatmaps}

dm <- integrated_T0_DE %>%
    select(all_of(condition_order)) %>%
  as.matrix()

hm <- Heatmap(dm,
               name = "lfc ",
               column_title = "Selected assay data, T0 DE",
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-1.5, 0, 1.5), c("#2166AC", "white", "#B2182B")),
               cluster_rows = FALSE,
               cluster_row_slices = TRUE, 
               cluster_columns = FALSE,
               row_split = integrated_T0_DE$Cluster,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = FALSE,
               row_names_gp = gpar(fontsize = 8),
               column_names_gp = gpar(fontsize = 10),
                left_annotation = haRow,
               use_raster = FALSE)
hm
if(create_pdfs){
  pdf("MDD_integrated_T0_DE_heatmap_lfc_no_z_kmeans.pdf") 
  draw(hm)
  res <- dev.off()
} 

#Create a matrix and heatmap of the mean cluster values by condition
 integrated_T0_DE_mean <- integrated_T0_DE %>%
  group_by(Cluster) %>%
  summarise(across(.cols = matches("_24|48"), .fns = mean))

dm_mean <- integrated_T0_DE_mean %>%
  select(-Cluster) %>%
  as.matrix()
rownames(dm_mean) <- paste0("Module_",integrated_T0_DE_mean$Cluster)

hm <- Heatmap(dm_mean,
               name = "lfc ",
               column_title = "T0 DE cluster averages",
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-1.5, 0, 1.5), c("#2166AC", "white", "#B2182B")),
               cluster_rows = FALSE,
               cluster_row_slices = FALSE, 
               cluster_columns = FALSE,
               #row_split = integrated_T0_DE$Cluster,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = TRUE,
               row_names_gp = gpar(fontsize = 8),
               column_names_gp = gpar(fontsize = 10),
                #left_annotation = haRow,
               use_raster = FALSE)
hm

```

```{r writeTables}
selectFeature <- function(df){
  #browser()
  res <- df %>%
    select(feature, Type) %>%
    mutate(analyte = str_remove(feature, "_.*")) %>%
    rename(assay = Type) %>%
    select(feature, analyte, assay, time, symbol)
return(res)
}

selectDerivedFeature <- function(df){
  #browser()
  res <- df %>%
    select(feature, FDR, Type)
return(res)
}

module_features <- integrated_T0_DE %>%
  arrange(Cluster, Type) %>%
  mutate(Cluster = paste0("module_", Cluster),
         Cluster = factor(Cluster, levels = unique(Cluster))) %>%
  split(.$Cluster) 

res <- write_xlsx(module_features,
                  path = "MDD_int_T0_DE_tables.xlsx")
```


### UMAPs

```{r UMAPAnalysis, fig.width=5.75, fig.height=4.75}

#Generate a 2d scatterplot of the UMAP dimensions and color by clusters, assay type

#Create annotation values
dm <- integrated_T0_DE %>%
  dplyr::select(-feature, -Cluster, -Type) %>%
  as.matrix()
rownames(dm) <- integrated_T0_DE$feature

custom_settings = umap.defaults
custom_settings$random_state <- 42
custom_settings$n_epochs = 200
custom_settings$n_neighbors = 15

if(file.exists(paste0("../integrated_analysis/MDD_",cluster_method,"_UMAP.rda"))){
  load(paste0("../integrated_analysis/MDD_",cluster_method,"_UMAP.rda"))
} else {
df_UMAP <- umap(dm, config = custom_settings, na.rm = TRUE)$layout %>%
  data.frame(feature = rownames(dm)) %>%
  rename(UMAP_1 = X1,
         UMAP_2 = X2) %>%
  left_join(integrated_T0_DE, by = "feature") 
save(df_UMAP, file = paste0("../integrated_analysis/MDD_",cluster_method,"_UMAP.rda"))
}

plot_UMAP_3d <- FALSE
if(plot_UMAP_3d){
  custom_settings$n_components = 3
  
  df_UMAP_3d <-  umap(dm, config = custom_settings, na.rm = TRUE)$layout %>%
    data.frame(feature = rownames(dm)) %>%
    rename(UMAP_1 = X1,
           UMAP_2 = X2,
           UMAP_3 = X3) %>%
    left_join(integrated_T0_DE, by = "feature")
  df_UMAP_3d$Cluster_color <- cluster_cols[df_UMAP_3d$Cluster]
  save(df_UMAP_3d, file = "MDD_UMAP_3d")
  
  library(rgl)
  plot3d(df_UMAP_3d$UMAP_1,
         df_UMAP_3d$UMAP_2,
         df_UMAP_3d$UMAP_3,
         col = factor(df_UMAP_3d$Cluster_color))
}

  p <- ggplot(df_UMAP, aes(x = UMAP_1,
                           y = UMAP_2,
                           colour = factor(Cluster))) +
    geom_point(size = 1, alpha = .6, shape = 16) +
    scale_color_manual(values = cluster_cols) +
    labs(title = paste("UMAP embedding colored by cluster"),
         colour = "Cluster") +
    guides(colour = guide_legend(override.aes = list(alpha = 1, size = 4))) +
    theme_bw()+
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line =element_blank())
  p
  
  if(create_pdfs) {
    pdf("MDD_ligands_umap_main.pdf")    
    print(p)
    res <- dev.off()
  } 
```

There are `r dim(dm)[1]` dots in the 2d UMAP that represent the significant differentially expressed features relative to T0 in the integrated matrix.  


```{r UMAPAnalysis2, fig.width=7.5, fig.height=4}
p <- ggplot(data = df_UMAP[df_UMAP$Type=="RNA",], aes(x = UMAP_1,
                                                      y = UMAP_2,
                                                      colour = factor(Type))) +
  geom_point(size = .8, alpha = .6) +
  scale_colour_manual(values = assay_cols)+
  labs(title = paste("UMAP embedding colored by assay"),
       colour = "Assay") +
  guides(colour = guide_legend(override.aes = list(alpha = 1, size = 4))) +
  theme_bw()+
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line =element_blank())
p <- p + geom_point(data = df_UMAP[!df_UMAP$Type=="RNA",],size = .8, alpha = .8)
p

if(create_pdfs) {
  pdf("MDD_ligands_umap_type.pdf") 
      print(p)
  res <- dev.off()
}

```

```{r highlightAssay, fig.width=2.5, fig.height=2.5}

p_list <- lapply(unique(df_UMAP$Type), function(assay){
  
  df <- df_UMAP
  
  p <- ggplot(data = df[!df$Type==assay,], 
              aes(x = UMAP_1,
                  y = UMAP_2,
                  color = Type)) +
    geom_point(color = "gray",size = 1, alpha = .4, shape = 16) +
    scale_colour_manual(values = assay_cols) +
    annotate("text",x = -2, y = -6, label = assay) +
    scale_size_area(limits = c(0, 30)) +
    labs()+
    guides(colour = FALSE,
           size = FALSE)+
    theme_bw()+
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line =element_blank())
  p <- p + geom_point(data = df[df$Type==assay,], 
                      size = 1,
                      alpha = .9,
                      shape = 16) 
  return(p)
  
})

res <- map(p_list, print)

if(create_pdfs) {
  pdf("MDD_ligands_umap_type_highlights.pdf") 
  res <- map(p_list, print)
  res <- dev.off()
}
```


```{r UMAPbyCondition, fig.width=2.5, fig.height=2.5, eval = TRUE}


df <- df_UMAP %>%
  rename("BMP2_EGF_24" = "BMP2+EGF_24",
         "IFNG_EGF_24" =  "IFNG+EGF_24",
         "TGFB_EGF_24" = "TGFB+EGF_24",
         "BMP2_EGF_48" = "BMP2+EGF_48",
         "IFNG_EGF_48" =  "IFNG+EGF_48",
         "TGFB_EGF_48" = "TGFB+EGF_48")
df_UMAP_conditions <- colnames(df)[str_detect(colnames(df_UMAP),"PBS|HGF|OSM|EGF|BMP2|IFNG|TGFB")] %>%
  str_replace("[+]","_")

p_list <- lapply(df_UMAP_conditions, function(condition){
  p <- ggplot(df, aes_string(x = "UMAP_1",
                             y = "UMAP_2",
                             colour = condition)) +
    geom_point(size = 1.5, alpha = .8, shape = 16) +
    annotate("text",x = -2, y = -6, label = condition)+
    scale_color_gradientn(colours = colorRampPalette(rev(brewer.pal(n = 7, name =
                                                                      "RdBu")))(100)) +
    labs()+
    guides(colour = FALSE)+
    theme_bw()+
    theme(text = element_text(size = 1),
          axis.title = element_blank(),
          panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(colour = "black"))
  return(p)
})
res <- map(p_list, print)
if(create_pdfs) {
  pdf("MDD_integrated_umap_by_condition.pdf")
  res <- map(p_list, print)
  res <- dev.off()
}

```

### phenotype analysis

```{r correlate_to_pheontypes}

level3File <- paste0("../IF/Data/MDD_IF_Level3.csv")

raw_df <- read_csv(level3File)
colnames(raw_df) <- raw_df[raw_df$X1 == "specimenName",]

if_df <- raw_df %>%
  select(matches("specimenName|24_C2|48_C2")) %>%
  rename(feature = specimenName) %>%
  filter(str_detect(feature, "_")) %>%
  mutate(across(-feature, as.numeric)) %>%
  pivot_longer(cols = matches("_C2_")) %>%
  mutate(condition = str_remove(name, "_C2_.$")) %>%
    mutate(condition = str_replace(condition, "BMP2","BMP2+EGF"),
         condition = str_replace(condition, "IFNG","IFNG+EGF"),
         condition = str_replace(condition, "TGFB","TGFB+EGF")) %>%
  group_by(feature, condition) %>%
  summarise(value = mean(value)) %>%
  ungroup() %>%
  pivot_wider(names_from = condition, values_from = value) %>%
  select(feature, condition_order)

if_dm <- if_df %>%
  select(-feature) %>%
  as.matrix()
  rownames(if_dm) <- if_df$feature

if_module_dm <- rbind(dm_mean, if_dm) %>%
  t
  
cor_dm <- cor(if_module_dm)

cor_hm <- Heatmap(cor_dm,
                   name = "correlation ",
                  row_names_gp = gpar(fontsize = 6),
                  column_names_gp = gpar(fontsize = 6),)
cor_hm

if(create_pdfs) {
  pdf("MDD_integrated_module_IF_correlations.pdf")
  res <- print(cor_hm)
  res <- dev.off()
}


#Reduce phenotype set
if_module_dm_reduced <- if_module_dm[,str_detect(colnames(if_module_dm),"Module|Well_Cell_Count|Mean_Cells_per_Cluster|Normalized_Second_Neighbor_Dist|Normalized_First_Neighbor_Dist|G2S_Proportion|G2_Proportion|DNA2n_Proportion|Edu_Positive_Proportion")]
cor_dm <- cor(if_module_dm_reduced)

cor_hm <- Heatmap(cor_dm,
                   name = "correlation",
                  row_names_gp = gpar(fontsize = 12),
                  column_names_gp = gpar(fontsize = 12),)
cor_hm

if(create_pdfs) {
  pdf("MDD_integrated_module_IF_correlations_reduced.pdf")
  res <- print(cor_hm)
  res <- dev.off()
}

```


### cluster analysis


```{r featureTypes, fig.width=8, fig.height=4}
#create a bar chart of the feature types
df <- integrated_T0_DE %>%
  #drop_na() %>%
  select(feature, Type) %>%
  distinct()

p <- ggplot(df, aes(x = Type, fill = Type)) +
  geom_bar() +
  coord_cartesian(ylim = c(0, 10000)) +
  scale_fill_manual(values = assay_cols)+
  labs(title = paste("Type distribution of the",length(unique(paste0(df$feature))), "features at unique timepoints in the MDD integrated dataset"),
       x ="Feature type") +
  theme_bw()+
  theme(axis.text.x =  element_text(angle = 90),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())

p

p_log <- ggplot(df, aes(x = Type, fill = Type)) +
  geom_bar() +
  scale_y_log10() +
  scale_fill_manual(values = assay_cols)+
  labs(title = paste("Type distribution of the",length(unique(paste0(df$feature))), "features at unique timepoints in the MDD integrated dataset"),
       x ="Feature type") +
  theme_bw()+
  theme(axis.text.x =  element_text(angle = 90),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())

p_log
if(create_pdfs){
  pdf("MDD_ligands_feature_type_distribution.pdf")
  print(p)  
  res <- dev.off()
  pdf("MDD_ligands_feature_type_distribution_log_scale.pdf")
  print(p_log)
  res <- dev.off()
} 

```


```{r gapStatistics, fig.width=4, fig.height=4, eval = FALSE}

plot_gap_custom <- function(x) {
  gstab = data.frame(x$Tab, k = seq_len(nrow(x$Tab)))
  p <- ggplot(gstab, aes(k, gap)) + 
    geom_line() +
    geom_errorbar(aes(ymax = gap + SE.sim,
                      ymin = gap - SE.sim), width=0.1) +
    geom_point(size = .5, col=  "red") +
    labs(title = paste("Gap analysis to determine cluster number,",cluster_method)) +
     theme_bw()+
  theme(axis.ticks = element_blank(),
        panel.border = element_blank(),
        axis.line =element_blank())
  return(p)
}

dm <- integrated_T0_DE %>%
    select(all_of(condition_order)) %>%
  as.matrix()

if(file.exists(paste0("../integrated_analysis/gss_",cluster_method,"_T0_DE.rda"))){
  load(paste0("../integrated_analysis/gss_",cluster_method,"_T0_DE.rda"))
} else {
  gss <- clusGap(dm, FUN = kmeans, K.max = 15, B = 100, verbose = FALSE)
  save(gss, file = paste0("../integrated_analysis/gss_",cluster_method,"_T0_DE.rda"))
}

  plot_gap_custom(gss)
if(create_pdfs){
  pdf("MDD_ligands_gap_cluster.pdf")
  p <- plot_gap_custom(gss)
  print(p)
  res <- dev.off()
}
# 
# p <- ggplot(integrated_T0_DE, aes(x = as.factor(Cluster), fill = Type)) +
#   geom_bar() +
#   scale_fill_manual(values = assay_cols)+
#   labs(x = "Cluster",
#        fill = "Assay") +
#   theme_bw()+
#   theme(axis.ticks = element_blank(),
#         panel.border = element_blank(),
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         axis.line =element_blank())
# p
# if(create_pdfs){
#   pdf("MDD_ligands_assay_cluster.pdf")
#   print(p)
#   res <- dev.off()
# }
```

```{r assayClusterdistribution, fig.width=8, fig.height=4, eval = TRUE}

p <- ggplot(integrated_T0_DE, aes(x = as.factor(Cluster), fill = Type)) +
  geom_bar(position = "dodge") +  
  scale_fill_manual(values = assay_cols) +
  labs(x = "Cluster",
       fill = "Assay") +
  facet_wrap(~Type, scales = "free_y") +
  theme_bw()+
  theme(#axis.title = element_blank(),
    #axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())
p

if(create_pdfs){
  pdf("MDD_ligands_cluster_feature_counts.pdf")
  print(p)
  res <- dev.off()
} 

```


This analysis can be interpreted to select the number of clusters in the dataset. It is based on a method described in Modern Statistics for Modern Biology by Susan Holmes and Wolfgang Huber http://web.stanford.edu/class/bios221/book/Chap-Clustering.html and is excerpted below.  

Taking the logarithm of the within-sum-of-squares (log(WSSk)) and comparing it to averages from simulated data with less structure can be a good way of choosing k. This is the basic idea of the gap statistic introduced by Tibshirani, Walther, and Hastie (2001). We compute log(WSSk) for a range of values of k, the number of clusters, and compare it to that obtained on reference data of similar dimensions with various possible ‘non-clustered’ distributions. We can use uniformly distributed data as we did above or data simulated with the same covariance structure as our original data.

The default choice for the number of clusters, k1, is the first value of k for which the gap is not larger than the first local maximum minus a standard error (see the manual page of the clusGap function). ... the choice recommended by Tibshirani, Walther, and Hastie (2001) is the smallest k such that gap(k)≥gap(k+1)−s′k+1...

The first local maximum is k = 13. This analysis is choosing to use k = `r clust_num` which is is the first value where the gap value minus its standard error is less than this local maximum at 13.  


<bksp>

<bksp>

###

