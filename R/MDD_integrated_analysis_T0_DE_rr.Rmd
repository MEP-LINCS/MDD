---
title: "MDD integrated analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache=FALSE, cache.lazy = FALSE, message=FALSE, warning = FALSE, fig.height=10, fig.width=14)

suppressMessages(library(tidyverse))
library(ComplexHeatmap)
library(circlize)
library(umap)
library(cluster)
library(RColorBrewer)
library(writexl)
#library(UpSetR)

source("../R/MDD_functions.R")
create_pdfs <- TRUE
write_csvs <- TRUE

```



```{r setup_parameters_and_metadata}
keep_PBS <- FALSE
PBS_pointer <- "_noPBS2"
if(keep_PBS) PBS_pointer <- ""

data_path <- paste0("../integrated_analysis/integrated_matrix_lfc_rr",PBS_pointer, ".csv")
p_values_path <- paste0("../integrated_analysis/integrated_adj_p_values", PBS_pointer, ".csv") 
shared_features_path <- paste0("../integrated_analysis/integrated_shared_features_rr", PBS_pointer, ".csv") 
unique_features_path <- paste0("../integrated_analysis/integrated_unique_features_rr", PBS_pointer, "_absDir.csv") 

#shared_clust_num <- 12
combined_clust_num <- 18
cluster_method <- "pam"

experimentalTimePoints <- c("_24", "_48")
if(keep_PBS) {
  ligand_order <-  c("PBS", "HGF", "OSM", "EGF","BMP2+EGF", "IFNG+EGF", "TGFB+EGF")
} else {
  ligand_order <-  c("HGF", "OSM", "EGF","BMP2+EGF", "IFNG+EGF", "TGFB+EGF")
}

condition_order <- paste0(rep(ligand_order, each = length(experimentalTimePoints)), rep(c("_24", "_48"), times = length(ligand_order)))

#create a named vector of color values for the Heatmap clusters
cluster_cols <- c(structure(RColorBrewer::brewer.pal(12, "Paired")[c(1:12)], names = 1:12), c("13" = "#222222", "14" = "#555555", "15" = "#999999", "16" = "#AAAAAA", "17" = "#BBBBBB", "18" = "#CCCCCC", "19" = "#DDDDDD"))

combined14_clusters <-c("1", "2", "3+4", "5", "6+16", "7", "8+17", "9", "10+15", "11", "12", "13", "14","18")

cluster14_cols <- c(structure(RColorBrewer::brewer.pal(12, "Paired")[1:12], names = combined14_clusters[1:12]), c("14" = "#222222", "18" = "#555555"))

ligand_cols <- c("CTRL" = "#7A4A2A",
                 "PBS" = "#8dd3c7",
                 "HGF" = "#80b1d3",
                 "OSM" = "#fdb462",
                 "EGF" = "#fb8072",
                 "BMP2+EGF" = "#b3de69",
                 "IFNG+EGF" = "#bebada",
                 "TGFB+EGF" = "#ffd92f")

#create factors for Up/Down unique features
up_down_cluster_levels <- paste(names(ligand_cols), rep(c("Negative", "Mixed", "Positive"), each = length(ligand_cols)), sep = "_")
 
up_down_cluster_colors <- rep(ligand_cols, times = 3)
names(up_down_cluster_colors) <- up_down_cluster_levels

```

This analysis is run with keep_PBS flag set to `r keep_PBS`.  
The cluster method is `r cluster_method`.  
Input files are `r data_path`, `r shared_features_path` and `r unique_features_path`.  


```{r prepData}

#Read in the integrated data, add EGF to some names, set order
if(!file.exists(data_path)) stop("cannot read ",data_path)
all_features_data <- read_csv(data_path) %>%
  pivot_longer(cols = matches("_24|_48"), names_to = "condition") %>%
  mutate(condition = str_replace(condition, "BMP2","BMP2+EGF"),
         condition = str_replace(condition, "IFNG","IFNG+EGF"),
         condition = str_replace(condition, "TGFB","TGFB+EGF"),
         feature_type =  paste(feature, Type, sep = "_")) %>%
  pivot_wider(names_from = condition, values_from = value) %>%
  select(feature, Type, feature_type, all_of(condition_order)) %>%
  drop_na

#Read in the integrated data, add EGF to some names, set order
if(!file.exists(unique_features_path)) stop("cannot read ",unique_features_path)
set.seed(42) #randomize row positions
unique_features <- read_csv(unique_features_path) %>%
  slice_sample(prop = 1)
unique_features_data <- unique_features%>%
  mutate(ligand = str_replace(ligand, "BMP2","BMP2+EGF"),
         ligand = str_replace(ligand, "IFNG","IFNG+EGF"),
         ligand = str_replace(ligand, "TGFB","TGFB+EGF"),
         feature_type =  paste(feature, Type, sep = "_"),
         Set = ligand) %>%
  select(ligand, feature_type, Abs_Direction, Set) %>%
  rename(Direction = Abs_Direction) %>%
  left_join(all_features_data, by = "feature_type") %>%
  rename(Cluster = ligand) %>%
  mutate(Cluster = paste(Cluster, Direction, sep = "_")) %>%
  drop_na

#Read in the integrated data, add EGF to some names, set order
if(!file.exists(shared_features_path)) stop("cannot read ",shared_features_path)
set.seed(42) #randomize row positions
shared_features <- read_csv(shared_features_path) %>%
  slice_sample(prop = 1)
shared_features_data <- shared_features %>%
  mutate(ligand = str_replace(ligand, "BMP2","BMP2+EGF"),
         ligand = str_replace(ligand, "IFNG","IFNG+EGF"),
         ligand = str_replace(ligand, "TGFB","TGFB+EGF"),
         feature_type =  paste(feature, Type, sep = "_"),
         Set = "shared") %>%
  select(feature_type, Set) %>%
  distinct() %>%
  left_join(all_features_data, by = c("feature_type" ))  %>%
  drop_na

set.seed(42) #randomize row positions
combined18_features_data <- bind_rows(shared_features_data, select(unique_features_data, -Direction, -Cluster)) %>%
  slice_sample(prop = 1)
assay_cols <- structure(RColorBrewer::brewer.pal(8, "Paired")[c(3, 2,6,5, 1)], names = unique(combined18_features_data$Type))

```
## {.tabset .tabset-fade}

### heatmap

```{r heatmaps}

#create a numeric matrix with feature row names
combined18_features_dm <- combined18_features_data %>%
  select(all_of(condition_order)) %>%
  as.matrix() 
rownames(combined18_features_dm) <- combined18_features_data$feature_type
combined18_features_dm <- combined18_features_dm[!is.nan(combined18_features_dm[,1]),]

#cluster all features 
if(cluster_method == "kmeans"){
  #seed the clustering with a fixed, random set of points
  set.seed(42)
  centers <- combined18_features_dm[sample(1:nrow(combined18_features_dm), size = combined18_clust_num, replace = FALSE),]
  clusters <- kmeans(x = combined18_features_dm, iter.max = 20, centers = centers)$cluster
} else if(cluster_method == "HA") {
  clust_obj <- hclust(dist(combined18_features_dm))
  clusters <- cutree(clust_obj, k = combined_clust_num)
} else if(cluster_method == "pam") {
  
  if(file.exists(paste0("../integrated_analysis/MDD_",cluster_method,"_clusters.rda"))){
    load(paste0("../integrated_analysis/MDD_",cluster_method,"_clusters.rda"))
  } else {
    set.seed(42)
    medoids <- sample(1:nrow(combined18_features_dm), size = combined_clust_num, replace = FALSE)
    clusters  <- pam(x = combined18_features_dm, k = combined_clust_num, medoids = medoids, cluster.only=TRUE, pamonce = 5)
    save(clusters, file = paste0("../integrated_analysis/MDD_",cluster_method,"_clusters.rda"))
  }
  
} else stop("unsupported cluster method chosen")

#Add the cluster assignements to the data
combined18_features_data_ann <-  tibble(feature_type = names(clusters),
                                      Cluster = clusters) %>%
  right_join(combined18_features_data, by = "feature_type") %>%
  mutate(Cluster = factor(Cluster, ordered = TRUE))

combined18_features_ann <- combined18_features_data_ann %>%
  select(Cluster, Type, Set) %>%
  as.data.frame()

#Create a matrix and heatmap of the mean combined18 values
combined18_features_data_mean <- combined18_features_data_ann %>%
  group_by(Cluster) %>%
  summarise(across(.cols = matches("_24|48"), .fns = mean))

combined18_features_count <- combined18_features_data_ann %>%
  group_by(Cluster) %>%
  count()

combined18_features_data_mean_dm <- combined18_features_data_mean %>%
  select(-Cluster) %>%
  as.matrix()
rownames(combined18_features_data_mean_dm) <- paste0("Module_",combined18_features_data_mean$Cluster,"_", combined18_features_count$n)

#Make heatmap with annotations
haRow_combined18 <- HeatmapAnnotation(df = combined18_features_ann,
                                    which = "row",
                                    col = list(Cluster = factor(cluster_cols, levels = cluster_cols, ordered = TRUE),
                                               Type = assay_cols,
                                               Set = c("shared" = "black", ligand_cols)))

hm_combined18 <- Heatmap(combined18_features_dm,
                       name = "lfc rr",
                       column_title = "combined18 features",
                       column_title_gp = gpar(fontsize = 12),
                       col = colorRamp2(c(-1.5, 0, 1.5), c("#2166AC", "white", "#B2182B")),
                       cluster_rows = FALSE,
                       cluster_row_slices = FALSE, 
                       cluster_columns = FALSE,
                       row_split = combined18_features_ann$Cluster,
                       row_gap = unit(2, "mm"),
                       row_title = " ",
                       show_row_names = FALSE,
                       row_names_gp = gpar(fontsize = 8),
                       column_names_gp = gpar(fontsize = 10),
                       left_annotation = haRow_combined18,
                       use_raster = FALSE)
hm_combined18

hm_combined18_mean <- Heatmap(combined18_features_data_mean_dm,
                            name = "lfc ",
                            column_title = "combined18 cluster means",
                            column_title_gp = gpar(fontsize = 12),
                            col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
                            cluster_rows = FALSE,
                            cluster_row_slices = FALSE,
                            cluster_columns = FALSE,
                            row_gap = unit(2, "mm"),
                            row_title = " ",
                            show_row_names = TRUE,
                            row_names_gp = gpar(fontsize = 8),
                            column_names_gp = gpar(fontsize = 10),
                            use_raster = FALSE)
hm_combined18_mean

#find correlations bewteen the modules and show cut to combine
# #Modules only set
# if_module_dm_reduced <- if_module_dm[,str_detect(colnames(if_module_dm),"Module")]
cor_dm <- cor(t(combined18_features_data_mean_dm),  method = "pearson")
hr = hclust(dist(cor_dm))
clusters = dendextend::cutree(hr, k = 14)
##Adding cuttree
##
cor_hm <- Heatmap(cor_dm,
                   name = "pearson\ncorrelation",
                  row_names_gp = gpar(fontsize = 10),
                  split = clusters,
                  column_names_gp = gpar(fontsize = 10),)
cor_hm

if(create_pdfs) {
  pdf("MDD_combined18_module_module_correlations_reduced.pdf",
      width = 9, height = 8)
  res <- print(cor_hm)
  res <- dev.off()
}

if(write_csvs) {
  write.csv(cor_dm, "MDD_combined18_module_module_correlations.csv")

}

#####
#Use the combined18 features data and the cluster assignments to
#create the combined14 dataset

combined14_features_data_ann <- combined18_features_data_ann %>%
    mutate(Cluster = as.character(Cluster),
      Cluster = case_when(Cluster %in% c("3","4") ~"3+4",
                          Cluster %in% c("6","16") ~"6+16",
                          Cluster %in% c("8", "17") ~"8+17",
                          Cluster %in% c("10","15") ~"10+15",
                               TRUE ~Cluster),
      Cluster = factor(Cluster, levels = combined14_clusters, ordered = TRUE)) %>%
  as.data.frame()

#Remove the cluster assignemnts to keep the code similar to the 
#other dataset processing
combined14_features_data <- combined14_features_data_ann %>%
  select(-Cluster)

#create a numeric matrix with feature row names
combined14_features_dm <- combined14_features_data %>%
  select(all_of(condition_order)) %>%
  as.matrix() 
rownames(combined14_features_dm) <- combined14_features_data$feature_type
combined14_features_dm <- combined14_features_dm[!is.nan(combined14_features_dm[,1]),]

combined14_features_ann <- combined14_features_data_ann %>%
  select(Cluster, Type, Set) %>%
  as.data.frame()

#Create a matrix and heatmap of the mean combined18 values
combined14_features_data_mean <- combined14_features_data_ann %>%
  group_by(Cluster) %>%
  summarise(across(.cols = matches("_24|48"), .fns = mean))

combined14_features_count <- combined14_features_data_ann %>%
  group_by(Cluster) %>%
  count()

combined14_features_data_mean_dm <- combined14_features_data_mean %>%
  select(-Cluster) %>%
  as.matrix()
rownames(combined14_features_data_mean_dm) <- paste0("Module_",combined14_features_data_mean$Cluster,"_", combined14_features_count$n)

#Make heatmap with annotations
haRow_combined14 <- HeatmapAnnotation(df = combined14_features_ann,
                                    which = "row",
                                    col = list(Cluster = factor(cluster14_cols, levels = cluster14_cols, ordered = TRUE),
                                               Type = assay_cols,
                                               Set = c("shared" = "black", ligand_cols)))

hm_combined14 <- Heatmap(combined14_features_dm,
                       name = "lfc rr",
                       column_title = "combined14 features",
                       column_title_gp = gpar(fontsize = 12),
                       col = colorRamp2(c(-1.5, 0, 1.5), c("#2166AC", "white", "#B2182B")),
                       cluster_rows = FALSE,
                       cluster_row_slices = FALSE, 
                       cluster_columns = FALSE,
                       row_split = combined14_features_ann$Cluster,
                       row_gap = unit(2, "mm"),
                       row_title = " ",
                       show_row_names = FALSE,
                       row_names_gp = gpar(fontsize = 8),
                       column_names_gp = gpar(fontsize = 10),
                       left_annotation = haRow_combined14,
                       use_raster = FALSE)
hm_combined14

hm_combined14_mean <- Heatmap(combined14_features_data_mean_dm,
                            name = "lfc ",
                            column_title = "combined14 cluster means",
                            column_title_gp = gpar(fontsize = 12),
                            col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
                            cluster_rows = FALSE,
                            cluster_row_slices = FALSE,
                            cluster_columns = FALSE,
                            row_gap = unit(2, "mm"),
                            row_title = " ",
                            show_row_names = TRUE,
                            row_names_gp = gpar(fontsize = 8),
                            column_names_gp = gpar(fontsize = 10),
                            use_raster = FALSE)
hm_combined14_mean

#####
if(create_pdfs){
  pdf("MDD_integrated_rr_combined18_heatmap.pdf") 
  draw(hm_combined18)
  draw(hm_combined18_mean)
  draw(hm_combined14)
  draw(hm_combined14_mean)
  res <- dev.off()
} 
# 
# hm_combined18_mean <- Heatmap(combined18_features_data_mean_dm,
#                name = "lfc ",
#                column_title = "combined18 cluster means",
#                column_title_gp = gpar(fontsize = 12),
#                col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
#                cluster_rows = TRUE,
#                cluster_row_slices = FALSE,
#                cluster_columns = FALSE,
#                row_gap = unit(2, "mm"),
#                row_title = " ",
#                show_row_names = TRUE,
#                row_names_gp = gpar(fontsize = 8),
#                column_names_gp = gpar(fontsize = 10),
#                use_raster = FALSE)

#######
#Shared features

#Create data and metadata matrices and annotations
#cluster and order by cluster value
# # 
# # shared_features_dm <- shared_features_data %>%
# #   select(all_of(condition_order)) %>%
# #   as.matrix() 
# # 
# # rownames(shared_features_dm) <- shared_features_data$feature_type
# # shared_features_dm <- shared_features_dm[!is.nan(shared_features_dm[,1]),]
# # 
# # #cluster shared matrix
# # if(cluster_method == "kmeans"){
# #   #seed the kmeans clustering with a fixed, random set of points
# # set.seed(42)
# # centers <- shared_features_dm[sample(1:nrow(shared_features_dm), size = shared_clust_num, replace = FALSE),]
# # clusters <- kmeans(x = shared_features_dm, iter.max = 20, centers = centers)$cluster
# # } else if(cluster_method == "HA") {
# #   clust_obj <- hclust(dist(shared_features_dm))
# #   clusters <- cutree(clust_obj, k = shared_clust_num)
# # } else if(cluster_method == "pam") {
# #    set.seed(42)
# # medoids <- sample(1:nrow(shared_features_dm), size = shared_clust_num, replace = FALSE)
# #   clusters  <- pam(x = shared_features_dm, k = shared_clust_num, medoids = medoids, cluster.only=TRUE, pamonce = 5)
# # } else stop("unsupported cluster method chosen")
# # 
# # shared_features_data_ann <-tibble(feature_type = names(clusters),
# #                  Cluster = clusters) %>%
# #   right_join(shared_features_data, by = "feature_type") %>%
# #   mutate(Cluster = factor(Cluster, levels = 1:shared_clust_num, ordered = TRUE))
# # 
# # shared_features_ann <-shared_features_data_ann %>%
# #     select(Cluster, Type) %>%
# #   as.data.frame()
# # 
# # haRow_shared <- HeatmapAnnotation(df = shared_features_ann,
# #                            which = "row",
# #                            col = list(Cluster = factor(cluster_cols, levels = cluster_cols, ordered = TRUE),
# #                                       Type = assay_cols))
# # 
# # hm_shared <- Heatmap(shared_features_dm,
# #                name = "lfc rr",
# #                column_title = "Shared features",
# #                column_title_gp = gpar(fontsize = 12),
# #                col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
# #                cluster_rows = FALSE,
# #                cluster_row_slices = TRUE, 
# #                cluster_columns = FALSE,
# #                row_split = shared_features_ann$Cluster,
# #                row_gap = unit(2, "mm"),
# #                row_title = " ",
# #                show_row_names = FALSE,
# #                row_names_gp = gpar(fontsize = 8),
# #                column_names_gp = gpar(fontsize = 10),
# #                left_annotation = haRow_shared,
# #                use_raster = FALSE)
# # hm_shared
# # if(create_pdfs){
# #   pdf("MDD_integrated_rr_shared_heatmap.pdf") 
# #   draw(hm_shared)
# #   res <- dev.off()
# # } 
# 
# #Create a matrix and heatmap of the mean shared cluster values
#  shared_features_data_mean <- shared_features_data_ann %>%
#   group_by(Cluster) %>%
#   summarise(across(.cols = matches("_24|48"), .fns = mean))
# 
#   shared_features_count <- shared_features_data_ann %>%
#   group_by(Cluster) %>%
#  count()
#   
# shared_features_data_mean_dm <- shared_features_data_mean %>%
#   select(-Cluster) %>%
#   as.matrix()
# rownames(shared_features_data_mean_dm) <- paste0("Module_",shared_features_data_mean$Cluster,"_", shared_features_count$n)
# 
# hm_shared_mean <- Heatmap(shared_features_data_mean_dm,
#                name = "lfc ",
#                column_title = "Shared cluster means",
#                column_title_gp = gpar(fontsize = 12),
#                col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
#                cluster_rows = TRUE,
#                cluster_row_slices = FALSE,
#                cluster_columns = FALSE,
#                row_gap = unit(2, "mm"),
#                row_title = " ",
#                show_row_names = TRUE,
#                row_names_gp = gpar(fontsize = 8),
#                column_names_gp = gpar(fontsize = 10),
#                use_raster = FALSE)

#make a heatmap of the unique features
#Create data and metadata matrices and annotations

unique_features_data_ann <- unique_features_data %>%
  mutate(Ligand = str_remove(Cluster, "_.*"),
         Ligand = factor(Ligand,  ordered = TRUE),
         Direction = factor(Direction, ordered = TRUE),
         Cluster = factor(Cluster, ordered = TRUE)) 

unique_features_ann <- unique_features_data_ann %>%
  select(Ligand, Direction, Type) %>%
  as.data.frame()

haRow_unique <- HeatmapAnnotation(df = unique_features_ann,
                                  which = "row",
                                  col = list(Ligand = factor(ligand_cols, levels = ligand_cols, ordered = TRUE),
                                             Type = assay_cols,
                                             Direction = factor(c("Negative" = "blue","Mixed" = "gray","Positive" = "red"))))

unique_features_data_dm<- unique_features_data_ann %>%
  select(all_of(condition_order)) %>%
  as.matrix()
rownames(unique_features_data_dm) <- unique_features_data_ann$feature

unique_features_data_mean <- unique_features_data_ann %>%
  group_by(Cluster) %>%
  summarise(across(.cols = matches("_24|48"), .fns = mean))

unique_features_count <- unique_features_data_ann %>%
  group_by(Cluster) %>%
  count()

unique_features_data_mean_dm <- unique_features_data_mean %>%
  select(-Cluster) %>%
  as.matrix()
rownames(unique_features_data_mean_dm) <- paste0(unique_features_data_mean$Cluster, "_",unique_features_count$n)

hm_unique <- Heatmap(unique_features_data_dm,
                     name = "lfc rr",
                     column_title = "Ligand-specific features",
                     column_title_gp = gpar(fontsize = 12),
                     col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
                     cluster_rows = FALSE,
                     cluster_row_slices = TRUE, 
                     cluster_columns = FALSE,
                     row_split = unique_features_data_ann$Cluster,
                     row_gap = unit(2, "mm"),
                     row_title = " ",
                     show_row_names = FALSE,
                     row_names_gp = gpar(fontsize = 2),
                     column_names_gp = gpar(fontsize = 10),
                     left_annotation = haRow_unique,
                     use_raster = FALSE)
hm_unique

hm_unique_mean <- Heatmap(unique_features_data_mean_dm,
                          name = "lfc ",
                          column_title = "Ligand-specific averages",
                          column_title_gp = gpar(fontsize = 12),
                          col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
                          cluster_rows = TRUE,
                          cluster_row_slices = FALSE,
                          cluster_columns = FALSE,
                          row_gap = unit(2, "mm"),
                          row_title = " ",
                          show_row_names = TRUE,
                          row_names_gp = gpar(fontsize = 8),
                          column_names_gp = gpar(fontsize = 10),
                          use_raster = FALSE)
hm_unique_mean
# ####
# # Heatmap of ligand-specific cycIF, RPPA, GCP features: a) all timepoints; b) 24+48H only. It will be good to see a few versions of this, eg: 1 heatmap with all assay types and fully clustered rows; 3 separate row-clustered assay-specific heatmaps
df <- unique_features_data_ann %>%
  filter(!Type %in% c("RNAseq", "motifs"))

df_dm<- df %>%
    select(all_of(condition_order)) %>%
  as.matrix()
rownames(df_dm) <- df$feature

df_ann <- df %>%
    select(Ligand, Direction, Type) %>%
  as.data.frame()

haRow_df <- HeatmapAnnotation(df = df_ann,
                                  which = "row",
                                  col = list(Ligand = factor(ligand_cols, levels = ligand_cols, ordered = TRUE),
                                             Type = assay_cols,
                                             Direction = factor(c("Negative" = "blue","Mixed" = "gray","Positive" = "red"))))

hm_noRNAseq <- Heatmap(df_dm,
               name = "lfc rr",
               column_title = "Unique features, no RNAseq, motifs",
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
               cluster_rows = TRUE,
               cluster_row_slices = TRUE,
               cluster_columns = FALSE,
               #row_split = df_ann$Cluster,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = TRUE,
               row_names_gp = gpar(fontsize = 5),
               column_names_gp = gpar(fontsize = 10),
               left_annotation = haRow_df,
               use_raster = FALSE)
hm_noRNAseq
# ####
# #GCP version
df <- unique_features_data_ann %>%
  filter(Type == "GCP")

df_dm<- df %>%
    select(all_of(condition_order)) %>%
  as.matrix()
rownames(df_dm) <- df$feature


df_ann <- df %>%
    select(Ligand, Direction, Type) %>%
  as.data.frame()

haRow_df <- HeatmapAnnotation(df = df_ann,
                                  which = "row",
                                  col = list(Ligand = factor(ligand_cols, levels = ligand_cols, ordered = TRUE),
                                             Type = assay_cols,
                                             Direction = factor(c("Negative" = "blue","Mixed" = "gray","Positive" = "red"))))

hm_GCP <- Heatmap(df_dm,
               name = "lfc rr",
               column_title = "Unique features, GCP",
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
               cluster_rows = TRUE,
               cluster_row_slices = TRUE,
               cluster_columns = FALSE,
               #row_split = df_ann$Cluster,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = TRUE,
               row_names_gp = gpar(fontsize = 8),
               column_names_gp = gpar(fontsize = 10),
               left_annotation = haRow_df,
               use_raster = FALSE)
hm_GCP
# #cycIF version
df <- unique_features_data_ann %>%
  filter(Type == "cycIF")

df_dm<- df %>%
    select(all_of(condition_order)) %>%
  as.matrix()
rownames(df_dm) <- df$feature

df_ann <- df %>%
    select(Ligand, Direction, Type) %>%
  as.data.frame()

haRow_df <- HeatmapAnnotation(df = df_ann,
                                  which = "row",
                                  col = list(Ligand = factor(ligand_cols, levels = ligand_cols, ordered = TRUE),
                                             Type = assay_cols,
                                             Direction = factor(c("Negative" = "blue","Mixed" = "gray","Positive" = "red"))))


hm_cycIF <- Heatmap(df_dm,
               name = "lfc rr",
               column_title = "Unique features, cycIF",
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
               cluster_rows = TRUE,
               cluster_row_slices = TRUE,
               cluster_columns = FALSE,
               #row_split = df_ann$Cluster,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = TRUE,
               row_names_gp = gpar(fontsize = 8),
               column_names_gp = gpar(fontsize = 10),
               left_annotation = haRow_df,
               use_raster = FALSE)
hm_cycIF
# #RPPA version
df <- unique_features_data_ann %>%
  filter(Type == "RPPA")

df_dm<- df %>%
    select(all_of(condition_order)) %>%
  as.matrix()
rownames(df_dm) <- df$feature

df_ann <- df %>%
    select(Ligand, Direction, Type) %>%
  as.data.frame()

haRow_df <- HeatmapAnnotation(df = df_ann,
                                  which = "row",
                                  col = list(Ligand = factor(ligand_cols, levels = ligand_cols, ordered = TRUE),
                                             Type = assay_cols,
                                             Direction = factor(c("Negative" = "blue","Mixed" = "gray","Positive" = "red"))))

hm_RPPA <- Heatmap(df_dm,
               name = "lfc rr",
               column_title = "Unique features, RPPA",
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
               cluster_rows = TRUE,
               cluster_row_slices = TRUE,
               cluster_columns = FALSE,
               #row_split = df_ann$Cluster,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = TRUE,
               row_names_gp = gpar(fontsize = 8),
               column_names_gp = gpar(fontsize = 10),
               left_annotation = haRow_df,
               use_raster = FALSE)
hm_RPPA
# 
# ####
if(create_pdfs){
  pdf("MDD_integrated_rr_unique_heatmap.pdf")
  draw(hm_unique)
  draw(hm_noRNAseq)
  draw(hm_GCP)
  draw(hm_cycIF)
  draw(hm_RPPA)
  res <- dev.off()
}
####
# #heatmaps sorted by ligand and direction
df <- unique_features_data_ann %>%
  filter(!Type %in% c("RNAseq", "motifs")) %>%
  arrange(Set, Direction)

df_dm<- df %>%
    select(all_of(condition_order)) %>%
  as.matrix()
rownames(df_dm) <- df$feature

df_ann <- df %>%
    select(Ligand, Direction, Type) %>%
  as.data.frame()

haRow_df <- HeatmapAnnotation(df = df_ann,
                                  which = "row",
                                  col = list(Ligand = factor(ligand_cols, levels = ligand_cols, ordered = TRUE),
                                             Type = assay_cols,
                                             Direction = factor(c("Negative" = "blue","Mixed" = "gray","Positive" = "red"))))

hm_noRNAseq <- Heatmap(df_dm,
               name = "lfc rr",
               column_title = "Unique features, no RNAseq, motifs",
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
               cluster_rows = FALSE,
               cluster_row_slices = FALSE,
               cluster_columns = FALSE,
               #row_split = df_ann$Cluster,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = TRUE,
               row_names_gp = gpar(fontsize = 8),
               column_names_gp = gpar(fontsize = 10),
               left_annotation = haRow_df,
               use_raster = FALSE)
hm_noRNAseq
# ####
# #GCP version
df <- unique_features_data_ann %>%
  filter(Type == "GCP") %>%
  arrange(Set, Direction)

df_dm<- df %>%
    select(all_of(condition_order)) %>%
  as.matrix()
rownames(df_dm) <- df$feature

df_ann <- df %>%
    select(Ligand, Direction, Type) %>%
  as.data.frame()

haRow_df <- HeatmapAnnotation(df = df_ann,
                                  which = "row",
                                  col = list(Ligand = factor(ligand_cols, levels = ligand_cols, ordered = TRUE),
                                             Type = assay_cols,
                                             Direction = factor(c("Negative" = "blue","Mixed" = "gray","Positive" = "red"))))

hm_GCP <- Heatmap(df_dm,
               name = "lfc rr",
               column_title = "Unique features, GCP",
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
               cluster_rows = FALSE,
               cluster_row_slices = FALSE,
               cluster_columns = FALSE,
               #row_split = df_ann$Cluster,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = TRUE,
               row_names_gp = gpar(fontsize = 8),
               column_names_gp = gpar(fontsize = 10),
               left_annotation = haRow_df,
               use_raster = FALSE)
hm_GCP
# #cycIF version
df <- unique_features_data_ann %>%
  filter(Type == "cycIF") %>%
  arrange(Set, Direction)

df_dm<- df %>%
    select(all_of(condition_order)) %>%
  as.matrix()
rownames(df_dm) <- df$feature

df_ann <- df %>%
    select(Ligand, Direction, Type) %>%
  as.data.frame()

haRow_df <- HeatmapAnnotation(df = df_ann,
                                  which = "row",
                                  col = list(Ligand = factor(ligand_cols, levels = ligand_cols, ordered = TRUE),
                                             Type = assay_cols,
                                             Direction = factor(c("Negative" = "blue","Mixed" = "gray","Positive" = "red"))))

hm_cycIF <- Heatmap(df_dm,
               name = "lfc rr",
               column_title = "Unique features, cycIF",
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
               cluster_rows = FALSE,
               cluster_row_slices = FALSE,
               cluster_columns = FALSE,
               #row_split = df_ann$Cluster,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = TRUE,
               row_names_gp = gpar(fontsize = 8),
               column_names_gp = gpar(fontsize = 10),
               left_annotation = haRow_df,
               use_raster = FALSE)
hm_cycIF
# #RPPA version
df <- unique_features_data_ann %>%
  filter(Type == "RPPA") %>%
  arrange(Set, Direction)

df_dm<- df %>%
    select(all_of(condition_order)) %>%
  as.matrix()
rownames(df_dm) <- df$feature

df_ann <- df %>%
    select(Ligand, Direction, Type) %>%
  as.data.frame()

haRow_df <- HeatmapAnnotation(df = df_ann,
                                  which = "row",
                                  col = list(Ligand = factor(ligand_cols, levels = ligand_cols, ordered = TRUE),
                                             Type = assay_cols,
                                             Direction = factor(c("Negative" = "blue","Mixed" = "gray","Positive" = "red"))))

hm_RPPA <- Heatmap(df_dm,
               name = "lfc rr",
               column_title = "Unique features, RPPA",
               column_title_gp = gpar(fontsize = 12),
               col = colorRamp2(c(-2, 0, 2), c("#2166AC", "white", "#B2182B")),
               cluster_rows = FALSE,
               cluster_row_slices = FALSE,
               cluster_columns = FALSE,
               #row_split = df_ann$Cluster,
               row_gap = unit(2, "mm"),
               row_title = " ",
               show_row_names = TRUE,
               row_names_gp = gpar(fontsize = 8),
               column_names_gp = gpar(fontsize = 10),
               left_annotation = haRow_df,
               use_raster = FALSE)
hm_RPPA

# 
# ####
if(create_pdfs){
  pdf("MDD_integrated_rr_unique_heatmap_ordered.pdf")
  draw(hm_noRNAseq)
  draw(hm_GCP)
  draw(hm_cycIF)
  draw(hm_RPPA)
  res <- dev.off()
}

####
#Create a matrix and heatmap of the mean Ligand-specific values

if(create_pdfs){
  pdf("MDD_unique_heatmaps.pdf") 
  draw(hm_unique)
  draw(hm_unique_mean)
  res <- dev.off()
} 

```

```{r writeTables}
selectFeature <- function(df){
  #browser()
  res <- df %>%
    select(feature, Type) %>%
    mutate(analyte = str_remove(feature, "_.*")) %>%
    rename(assay = Type) %>%
    select(feature, analyte, assay, time, symbol)
return(res)
}

selectDerivedFeature <- function(df){
  #browser()
  res <- df %>%
    select(feature, FDR, Type)
return(res)
}

module_features <- combined18_features_data_ann %>%
  arrange(Cluster, Type) %>%
  mutate(Cluster = paste0("module_", Cluster),
         Cluster = factor(Cluster, levels = unique(Cluster))) %>%
  split(.$Cluster) 

res <- write_xlsx(module_features,
                  path = "MDD_int_rr_combined18_tables.xlsx")

combined14_features <- combined14_features_data_ann %>%
  arrange(Cluster, Type) %>%
  mutate(Cluster = paste0("module_", Cluster),
         Cluster = factor(Cluster, levels = unique(Cluster))) %>%
  split(.$Cluster) 

res <- write_xlsx(combined14_features,
                  path = "MDD_int_rr_combined14_tables.xlsx")

##### Randomized cluster assignments for null set analysis
module_features_null <- combined18_features_data_ann %>%
    mutate(Cluster = Cluster[sample(nrow(combined18_features_data_ann))]) %>%
  arrange(Cluster, Type) %>%
  mutate(Cluster = paste0("module_", Cluster),
         Cluster = factor(Cluster, levels = unique(Cluster))) %>%
  split(.$Cluster) 

res <- write_xlsx(module_features_null,
                  path = "MDD_int_rr_combined18_tables_null.xlsx")
# #####
# module_features <- shared_features_data_ann %>%
#   arrange(Cluster, Type) %>%
#   mutate(Cluster = paste0("module_", Cluster),
#          Cluster = factor(Cluster, levels = unique(Cluster))) %>%
#   split(.$Cluster) 
# 
# res <- write_xlsx(module_features,
#                   path = "MDD_int_rr_shared_tables.xlsx")

module_features <- unique_features_data %>%
  arrange(Cluster, Type) %>%
  mutate(Cluster = paste0("module_", Cluster),
         Cluster = factor(Cluster, levels = unique(Cluster))) %>%
  split(.$Cluster) 

res <- write_xlsx(module_features,
                  path = "MDD_int_rr_unique_tables.xlsx")
```


### UMAPs

```{r UMAPAnalysis, fig.width=5.75, fig.height=4.75}

#Generate a 2d scatterplot of the UMAP dimensions and color by clusters, assay type

#Create annotation values
dm <- combined14_features_data_ann %>%
  dplyr::select(-feature, -Cluster, -Type, -feature_type, -Set) %>%
  as.matrix()
rownames(dm) <- combined14_features_data_ann$feature_type

custom_settings = umap.defaults
custom_settings$random_state <- 42
custom_settings$n_epochs = 500
custom_settings$n_neighbors = 25

if(file.exists(paste0("../integrated_analysis/MDD_",cluster_method,"_combined14_UMAP.rda"))){
  load(paste0("../integrated_analysis/MDD_",cluster_method,"_combined14_UMAP.rda"))
} else {
df_UMAP <- umap(dm, config = custom_settings, na.rm = TRUE)$layout %>%
  data.frame(feature_type = rownames(dm)) %>%
  rename(UMAP_1 = X1,
         UMAP_2 = X2) %>%
  left_join(combined14_features_data_ann, by = "feature_type") 
save(df_UMAP, file = paste0("../integrated_analysis/MDD_",cluster_method,"_combined14_UMAP.rda"))
}

# plot_UMAP_3d <- FALSE
# if(plot_UMAP_3d){
#   custom_settings$n_components = 3
#   
#   df_UMAP_3d <-  umap(dm, config = custom_settings, na.rm = TRUE)$layout %>%
#     data.frame(feature = rownames(dm)) %>%
#     rename(UMAP_1 = X1,
#            UMAP_2 = X2,
#            UMAP_3 = X3) %>%
#     left_join(integrated_shared, by = "feature")
#   df_UMAP_3d$Cluster_color <- cluster_cols[df_UMAP_3d$Cluster]
#   save(df_UMAP_3d, file = "MDD_UMAP_3d")
#   
#   library(rgl)
#   plot3d(df_UMAP_3d$UMAP_1,
#          df_UMAP_3d$UMAP_2,
#          df_UMAP_3d$UMAP_3,
#          col = factor(df_UMAP_3d$Cluster_color))
# }

  p <- ggplot(df_UMAP, aes(x = UMAP_1,
                           y = UMAP_2,
                           colour = factor(Cluster))) +
    geom_point(size = 1, alpha = .6, shape = 16) +
    scale_color_manual(values = cluster14_cols) +
    labs(title = paste("UMAP embedding colored by cluster, combined14"),
         colour = "Cluster") +
    guides(colour = guide_legend(override.aes = list(alpha = 1, size = 4))) +
    theme_bw()+
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line =element_blank())
  p
  
  if(create_pdfs) {
    pdf("MDD_combined14_umap_main.pdf")    
    print(p)
    res <- dev.off()
  } 
```

There are `r dim(dm)[1]` dots in the 2d UMAP that represent the significant differentially expressed features relative to T0 in the combined14-features integrated matrix.  


```{r UMAPAnalysis2, fig.width=7.5, fig.height=4}
p <- ggplot(data = df_UMAP[df_UMAP$Type=="RNA",], aes(x = UMAP_1,
                                                      y = UMAP_2,
                                                      colour = factor(Type))) +
  geom_point(size = .8, alpha = .6) +
  scale_colour_manual(values = assay_cols)+
  labs(title = paste("UMAP embedding colored by assay, combined14"),
       colour = "Assay") +
  guides(colour = guide_legend(override.aes = list(alpha = 1, size = 4))) +
  theme_bw()+
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line =element_blank())
p <- p + geom_point(data = df_UMAP[!df_UMAP$Type=="RNA",],size = .8, alpha = .8)
p

if(create_pdfs) {
  pdf("MDD_ligands_combined14_umap_type.pdf") 
      print(p)
  res <- dev.off()
}

```

```{r highlightAssay, fig.width=2.5, fig.height=2.5}

p_list <- lapply(unique(df_UMAP$Type), function(assay){
  
  df <- df_UMAP
  
  p <- ggplot(data = df[!df$Type==assay,], 
              aes(x = UMAP_1,
                  y = UMAP_2,
                  color = Type)) +
    geom_point(color = "gray",size = 1, alpha = .4, shape = 16) +
    scale_colour_manual(values = assay_cols) +
    annotate("text",x = -2, y = -6, label = assay) +
    scale_size_area(limits = c(0, 30)) +
    labs()+
    guides(colour = FALSE,
           size = FALSE)+
    theme_bw()+
    theme(axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line =element_blank())
  p <- p + geom_point(data = df[df$Type==assay,], 
                      size = 1,
                      alpha = .9,
                      shape = 16) 
  return(p)
  
})

res <- map(p_list, print)

if(create_pdfs) {
  pdf("MDD_ligands_combined14_umap_type_highlights.pdf") 
  res <- map(p_list, print)
  res <- dev.off()
}
```


```{r UMAPbyCondition, fig.width=2.5, fig.height=2.5, eval = TRUE}


df <- df_UMAP %>%
  rename("BMP2_EGF_24" = "BMP2+EGF_24",
         "IFNG_EGF_24" =  "IFNG+EGF_24",
         "TGFB_EGF_24" = "TGFB+EGF_24",
         "BMP2_EGF_48" = "BMP2+EGF_48",
         "IFNG_EGF_48" =  "IFNG+EGF_48",
         "TGFB_EGF_48" = "TGFB+EGF_48")
df_UMAP_conditions <- colnames(df)[str_detect(colnames(df_UMAP),"PBS|HGF|OSM|EGF|BMP2|IFNG|TGFB")] %>%
  str_replace("[+]","_")

p_list <- lapply(df_UMAP_conditions, function(condition){
  p <- ggplot(df, aes_string(x = "UMAP_1",
                             y = "UMAP_2",
                             colour = condition)) +
    geom_point(size = 1.5, alpha = .8, shape = 16) +
    annotate("text",x = -2, y = -6, label = condition)+
    scale_color_gradientn(colours = colorRampPalette(rev(brewer.pal(n = 7, name =
                                                                      "RdBu")))(100)) +
    labs()+
    guides(colour = FALSE)+
    theme_bw()+
    theme(text = element_text(size = 1),
          axis.title = element_blank(),
          panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(colour = "black"))
  return(p)
})
res <- map(p_list, print)
if(create_pdfs) {
  pdf("MDD_integrated_combined14_umap_by_condition.pdf")
  res <- map(p_list, print)
  res <- dev.off()
}

```

### phenotype analysis

```{r correlate_to_phenotypes}

#start with level 3 IF data from synapse
level3File <- paste0("../IF/Data/MDD_IF_Level3.csv")
raw_df <- read_csv(level3File)
colnames(raw_df) <- raw_df[raw_df$X1 == "specimenName",]

#filter to 24 and 48 hour
if_df <- raw_df %>%
  select(matches("specimenName|24_C2|48_C2")) %>%
  rename(feature = specimenName) %>%
  filter(str_detect(feature, "_")) %>%
  mutate(across(-feature, as.numeric)) %>%
  pivot_longer(cols = matches("_C2_")) %>%
  mutate(condition = str_remove(name, "_C2_.$")) %>%
    mutate(condition = str_replace(condition, "BMP2","BMP2+EGF"),
         condition = str_replace(condition, "IFNG","IFNG+EGF"),
         condition = str_replace(condition, "TGFB","TGFB+EGF")) %>%
  group_by(feature, condition) %>%
  summarise(value = mean(value), .groups = "drop") %>%
  ungroup() %>%
  pivot_wider(names_from = condition, values_from = value) %>%
  select(feature, all_of(condition_order))

#Add migration data in the same format
migration <- read_csv("../integrated_analysis/Data/MDD_migration_distance_lineage_T0.csv") %>%
  filter(thour %in%c(24, 48),
         !treatment == "PBS") %>%
    mutate(condition = paste0(treatment,"_",thour),
           feature = "migration_distance")  %>%
  select(-treatment, -thour) %>%
  pivot_wider(names_from = condition, values_from = lineage_length_mean)

if_df_migration <- if_df %>%
  bind_rows(migration) 

if_dm <- if_df_migration %>%
  select(-feature) %>%
  as.matrix()
  rownames(if_dm) <- if_df_migration$feature
  
# combined14_features_data_mean_df <- combined14_features_data_ann %>%
#   group_by(Cluster) %>%
#       summarise(across(.cols = matches("_24|48"), .fns = mean)) %>%
#     ungroup() %>%
#   mutate(Cluster = paste0("Module_",as.integer(Cluster)))
# combined14_features_data_mean_dm <- combined14_features_data_mean_df %>%
#   select(-Cluster) %>%
#   as.matrix()
# rownames(combined14_features_data_mean_dm) <- combined14_features_data_mean_df$Cluster
  
if_module_dm <- rbind(combined14_features_data_mean_dm, if_dm) %>%
  t
  
cor_dm <- cor(if_module_dm, method ="pearson")

cor_hm <- Heatmap(cor_dm,
                   name = "pearson\ncorrelation ",
                  row_names_gp = gpar(fontsize = 6),
                  column_names_gp = gpar(fontsize = 6),)
cor_hm

if(create_pdfs) {
  pdf("MDD_combined14_IF_correlations.pdf")
  res <- print(cor_hm)
  res <- dev.off()
}

#Reduce phenotype set
if_module_dm_reduced <- if_module_dm[,str_detect(colnames(if_module_dm),"Module|Well_Cell_Count|Mean_Cells_per_Cluster|Normalized_Second_Neighbor_Dist|DNA2n_Proportion|Edu_Positive_Proportion|MeanIntensity_KRT5|StdIntensity_KRT5|MinIntensity_KRT5|_Negative|_Positive|migration_distance")]
cor_dm <- cor(if_module_dm_reduced,  method ="pearson")

cor_hm <- Heatmap(cor_dm,
                   name = "pearson\ncorrelation",
                  row_names_gp = gpar(fontsize = 10),
                  column_names_gp = gpar(fontsize = 10),)
cor_hm

if(create_pdfs) {
  pdf("MDD_combined14_IF_correlations_reduced.pdf",
      width = 9, height = 8)
  res <- print(cor_hm)
  res <- dev.off()
}


#Modules vs IF  set
if_modules_dm <- if_module_dm[,str_detect(colnames(if_module_dm),"Module|_Negative$|_Positive$")]

if_phenotypes_dm <- if_module_dm[,str_detect(colnames(if_module_dm), "Well_Cell_Count|Mean_Cells_per_Cluster|Normalized_Second_Neighbor_Dist|DNA2n_Proportion|Edu_Positive_Proportion|MeanIntensity_KRT5|MinIntensity_KRT5|migration_distance")]
cor_dm <- cor(if_modules_dm, if_phenotypes_dm,  method ="pearson")

cor_hm <- Heatmap(cor_dm,
                   name = "pearson\ncorrelation",
                  row_names_gp = gpar(fontsize = 10),
                  column_names_gp = gpar(fontsize = 10),)
cor_hm

if(create_pdfs) {
  pdf("MDD_combined14_module_phenotype_correlations_reduced.pdf",
      width = 9, height = 8)
  res <- print(cor_hm)
  res <- dev.off()
}

```


### cluster analysis


```{r featureTypes, fig.width=8, fig.height=4}
# #create a bar chart of the shared feature types
# df <- shared_features_data %>%
#   #drop_na() %>%
#   select(feature, Type) %>%
#   distinct()
# 
# p <- ggplot(df, aes(x = Type, fill = Type)) +
#   geom_bar() +
#   coord_cartesian(ylim = c(0, 10000)) +
#   scale_fill_manual(values = assay_cols)+
#   labs(title = paste("Type distribution of the",length(unique(paste0(df$feature))), "features at unique timepoints in the shared-features MDD integrated dataset"),
#        x ="Feature type") +
#   theme_bw()+
#   theme(axis.text.x =  element_text(angle = 90),
#     axis.ticks = element_blank(),
#     panel.border = element_blank(),
#     panel.grid.major = element_blank(),
#     panel.grid.minor = element_blank(),
#     axis.line =element_blank())
# 
# p
# 
# p_log <- ggplot(df, aes(x = Type, fill = Type)) +
#   geom_bar() +
#   scale_y_log10() +
#   scale_fill_manual(values = assay_cols)+
#   labs(title = paste("Type distribution of the",length(unique(paste0(df$feature))), "shared features at unique timepoints in the MDD integrated dataset"),
#        x ="Feature type") +
#   theme_bw()+
#   theme(axis.text.x =  element_text(angle = 90),
#     axis.ticks = element_blank(),
#     panel.border = element_blank(),
#     panel.grid.major = element_blank(),
#     panel.grid.minor = element_blank(),
#     axis.line =element_blank())
# 
# p_log
# if(create_pdfs){
#   pdf("MDD_shared_feature_type_distribution.pdf")
#   print(p)  
#   res <- dev.off()
#   pdf("MDD_shared_feature_type_distribution_log_scale.pdf")
#   print(p_log)
#   res <- dev.off()
# } 

#create a bar chart of the combined14 feature types
df <- combined14_features_data %>%
  #drop_na() %>%
  select(feature, Type) %>%
  distinct()

p <- ggplot(df, aes(x = Type, fill = Type)) +
  geom_bar() +
  coord_cartesian(ylim = c(0, 10000)) +
  scale_fill_manual(values = assay_cols)+
  labs(title = paste("Type distribution of the",length(unique(paste0(df$feature))), "features at unique timepoints in the combined14-features MDD integrated dataset"),
       x ="Feature type") +
  theme_bw()+
  theme(axis.text.x =  element_text(angle = 90),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())

p

p_log <- ggplot(df, aes(x = Type, fill = Type)) +
  geom_bar() +
  scale_y_log10() +
  scale_fill_manual(values = assay_cols)+
  labs(title = paste("Type distribution of the",length(unique(paste0(df$feature))), "combined14 features at unique timepoints in the MDD integrated dataset"),
       x ="Feature type") +
  theme_bw()+
  theme(axis.text.x =  element_text(angle = 90),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())

p_log
if(create_pdfs){
  pdf("MDD_combined14_feature_type_distribution.pdf")
  print(p)  
  res <- dev.off()
  pdf("MDD_combined14_feature_type_distribution_log_scale.pdf")
  print(p_log)
  res <- dev.off()
} 

```


```{r gapStatistics, fig.width=4, fig.height=4, eval = TRUE}

plot_gap_custom <- function(x, dataset_name = "") {
  gstab = data.frame(x$Tab, k = seq_len(nrow(x$Tab)))
  p <- ggplot(gstab, aes(k, gap)) + 
    geom_line() +
    geom_errorbar(aes(ymax = gap + SE.sim,
                      ymin = gap - SE.sim), width=0.1) +
    geom_point(size = .5, col=  "red") +
    labs(title = paste("Gap analysis,",cluster_method, dataset_name)) +
     theme_bw()+
  theme(axis.ticks = element_blank(),
        panel.border = element_blank(),
        axis.line =element_blank(),
        title = element_text(size = 8))
  return(p)
}

dm <- combined18_features_data %>%
    select(all_of(condition_order)) %>%
  as.matrix()

if(file.exists(paste0("../integrated_analysis/gss_",cluster_method,"_combined18.rda"))){
  load(paste0("../integrated_analysis/gss_",cluster_method,"_combined18.rda"))
} else {
  gss_combined18 <- clusGap(dm, FUN = pam, pamonce = 5, K.max = 25, B = 100, verbose = FALSE)
  save(gss_combined18, file = paste0("../integrated_analysis/gss_",cluster_method,"_combined18.rda"))
}

  plot_gap_custom(gss_combined18, "combined18")
if(create_pdfs){
  pdf("MDD_combined18_gap_cluster.pdf")
  p <- plot_gap_custom(gss_combined18)
  print(p)
  res <- dev.off()
}

# #Shared gap analysis
# dm <- shared_features_data %>%
#     select(all_of(condition_order)) %>%
#   as.matrix()
# 
# if(file.exists(paste0("../integrated_analysis/gss_",cluster_method,"_shared.rda"))){
#   load(paste0("../integrated_analysis/gss_",cluster_method,"_shared.rda"))
# } else {
#   gss_shared <- clusGap(dm, FUN = pam, pamonce = 5, K.max = 25, B = 100, verbose = FALSE)
#   save(gss_shared, file = paste0("../integrated_analysis/gss_",cluster_method,"_shared.rda"))
# }
# 
#   plot_gap_custom(gss_shared, "shared")
# if(create_pdfs){
#   pdf("MDD_shared_gap_cluster.pdf")
#   p <- plot_gap_custom(gss_shared)
#   print(p)
#   res <- dev.off()
# }
```

```{r assayClusterdistribution, fig.width=8, fig.height=4, eval = TRUE}
# 
# #Shared cluster analysis
# p_hist <- ggplot(shared_features_data_ann, aes(x = as.factor(Cluster), fill = Type)) +
#   geom_bar(position = "dodge") +  
#   scale_fill_manual(values = assay_cols) +
#   labs(title = "Shared cluster analysis",
#        x = "Cluster",
#        fill = "Assay") +
#   facet_wrap(~Type, scales = "free_y") +
#   theme_bw()+
#   theme(#axis.title = element_blank(),
#     #axis.text = element_blank(),
#     axis.ticks = element_blank(),
#     panel.border = element_blank(),
#     panel.grid.major = element_blank(),
#     panel.grid.minor = element_blank(),
#     axis.line =element_blank())
# p_hist
# 
# df <- shared_features_data_ann %>%
#   group_by(Type, Cluster) %>%
#   count() %>%
#   ungroup()
# 
# p <- ggplot(df, aes(x = n, fill = Type)) +
#   geom_density() +  
#   scale_fill_manual(values = assay_cols) +
#   labs(title = "Shared cluster analysis",
#        x = "feature count",
#        fill = "Assay") +
#   facet_wrap(~Type, scales = "free") +
#   theme_bw()+
#   theme(#axis.title = element_blank(),
#     #axis.text = element_blank(),
#     axis.ticks = element_blank(),
#     panel.border = element_blank(),
#     panel.grid.major = element_blank(),
#     panel.grid.minor = element_blank(),
#     axis.line =element_blank())
# p
# 
# if(create_pdfs){
#   pdf("MDD_shared_cluster_feature_counts.pdf")
#    print(p_hist)
#    print(p)
#   res <- dev.off()
# } 

#Ligand-specific analysis
p_hist <- ggplot(unique_features_data_ann, aes(x = as.factor(Cluster), fill = Type)) +
  geom_bar(position = "dodge") +  
  scale_fill_manual(values = assay_cols) +
  labs(title = "Ligand-specific cluster analysis",
       x = "Cluster",
       fill = "Assay") +
  facet_wrap(~Type, scales = "free_y") +
  theme_bw()+
  theme(#axis.title = element_blank(),
    axis.text.x = element_text(angle = 90),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())
p_hist

#color bars by ligand 
df <- unique_features_data_ann %>%
  mutate(ligand = str_remove(Cluster, "_.*"))
p_ligand <- ggplot(df, aes(x = as.factor(Cluster), fill = ligand)) +
  geom_bar(position = "dodge") +  
  scale_fill_manual(values = ligand_cols) +
  labs(title = "Ligand-specific cluster analysis",
       x = "Cluster",
       fill = "Ligand") +
  facet_wrap(~Type, scales = "free_y") +
  theme_bw()+
  theme(#axis.title = element_blank(),
    axis.text.x = element_text(angle = 90),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())
p_ligand

####
df <- unique_features_data_ann %>%
  group_by(Type, Cluster) %>%
  count() %>%
  ungroup()

p <- ggplot(df, aes(x = n, fill = Type)) +
  geom_density() +  
  scale_fill_manual(values = assay_cols) +
  labs(title = "Ligand-specific analysis",
       x = "feature count",
       fill = "Assay") +
  facet_wrap(~Type, scales = "free") +
  theme_bw()+
  theme(#axis.title = element_blank(),
    axis.text.x = element_text(angle = 0),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())
p

if(create_pdfs){
  pdf("MDD_unique_cluster_feature_counts.pdf")
   print(p_hist)
   print(p_ligand)
   print(p)
  res <- dev.off()
} 

#combined14 cluster analysis
p_hist <- ggplot(combined14_features_data_ann, aes(x = as.factor(Cluster), fill = Type)) +
  geom_bar(position = "dodge") +  
  scale_fill_manual(values = assay_cols) +
  labs(title = "combined14 cluster analysis",
       x = "Cluster",
       fill = "Assay") +
  facet_wrap(~Type, scales = "free_y") +
  theme_bw()+
  theme(#axis.title = element_blank(),
    #axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())
p_hist

df <- combined14_features_data_ann %>%
  group_by(Type, Cluster) %>%
  count() %>%
  ungroup()

p <- ggplot(df, aes(x = n, fill = Type)) +
  geom_density() +  
  scale_fill_manual(values = assay_cols) +
  labs(title = "combined14 cluster analysis",
       x = "feature count",
       fill = "Assay") +
  facet_wrap(~Type, scales = "free") +
  theme_bw()+
  theme(#axis.title = element_blank(),
    #axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line =element_blank())
p

if(create_pdfs){
  pdf("MDD_combined14_cluster_feature_counts.pdf")
     print(p_hist)
     print(p)
  res <- dev.off()
} 

```


This analysis can be interpreted to select the number of clusters in the dataset. It is based on a method described in Modern Statistics for Modern Biology by Susan Holmes and Wolfgang Huber http://web.stanford.edu/class/bios221/book/Chap-Clustering.html and is excerpted below.  

Taking the logarithm of the within-sum-of-squares (log(WSSk)) and comparing it to averages from simulated data with less structure can be a good way of choosing k. This is the basic idea of the gap statistic introduced by Tibshirani, Walther, and Hastie (2001). We compute log(WSSk) for a range of values of k, the number of clusters, and compare it to that obtained on reference data of similar dimensions with various possible ‘non-clustered’ distributions. We can use uniformly distributed data as we did above or data simulated with the same covariance structure as our original data.

The default choice for the number of clusters, k1, is the first value of k for which the gap is not larger than the first local maximum minus a standard error (see the manual page of the clusGap function). ... the choice recommended by Tibshirani, Walther, and Hastie (2001) is the smallest k such that gap(k)≥gap(k+1)−s′k+1...

#### combined18 dataset analysis  

Three of the methods for choosing k using a gap statitistic are:  
"Tibs2001SEmax": `r maxSE(gss_combined18$Tab[,'gap'], SE.f = gss_combined18$Tab[,'SE.sim'],
      method = c("Tibs2001SEmax"),
      SE.factor = 1) `  
      
uses the criterion, Tibshirani et al (2001) proposed: “the smallest k such that f(k) ≥ f(k+1) - s_{k+1}”. Note that this chooses k = 1 when all standard deviations are larger than the differences f(k+1) - f(k).


"firstSEmax": `r maxSE(gss_combined18$Tab[,'gap'], SE.f = gss_combined18$Tab[,'SE.sim'],
      method = c("firstSEmax"),
      SE.factor = 1) `  
      
location of the first f() value which is not smaller than the first local maximum minus SE.factor * SE.f[], i.e, within an “f S.E.” range of that maximum (see also SE.factor).

This, the default, has been proposed by Martin Maechler in 2012, when adding clusGap() to the cluster package, after having seen the "globalSEmax" proposal (in code) and read the "Tibs2001SEmax" proposal.

"globalSEmax": `r maxSE(gss_combined18$Tab[,'gap'], SE.f = gss_combined18$Tab[,'SE.sim'],
      method = c("globalSEmax"),
      SE.factor = 1)`    
      
(used in Dudoit and Fridlyand (2002), supposedly following Tibshirani's proposition): location of the first f() value which is not smaller than the global maximum minus SE.factor * SE.f[], i.e, within an “f S.E.” range of that maximum (see also SE.factor).



###




```{r compare_to_previous, eval = FALSE}
### z score vs DE analysis
path <- "../integrated_analysis/Data/MDD_ligand_module_features.xlsx"
integrated_data <- lapply(readxl::excel_sheets(path), readxl::read_xlsx, path = path ) %>%
  bind_rows(.id = "module") %>%
  mutate(module = readxl::excel_sheets(path)[as.integer(module)])

int_genes <- integrated_data %>%
  filter(assay == "RNA",
         time %in% c(24,48)) %>%
  rename(Cluster = module) %>%
  select(Cluster, symbol) %>%
  mutate(Cluster = str_replace(Cluster, "module_","int_")) %>%
  distinct

set_genes <- combined18_features_data_ann %>%
  filter(Type == "RNAseq") %>%
  rename(symbol = feature) %>%
  select(Cluster, symbol) %>%
  mutate(Cluster = paste0("set_",Cluster)) %>%
  distinct

genes <- bind_rows(int_genes, set_genes) %>%
  mutate(member = 1) %>%
  pivot_wider(names_from = Cluster, values_from = member, values_fill = 0) %>%
  rename(Name = symbol) %>%
  mutate(Name = as.factor(Name),
         across(where(is.numeric), as.integer)) %>%
  as.data.frame()

upset_obj <- upset(genes, nset = 32)

upset_obj

pdf("combined18_comparisons.pdf", width = 10, height = 8)
upset_obj
res = dev.off()
#######```
# We want to compare the features identified using set analysis of differentially expressed features to the prior method based on z scores of transformed assay values.  
# 
# #### Method  
# 
# Filter both matrices to 24 and 48 hour, RNAseq features and perform a set analysis on the modules in each dataset.  
```



### Compare T0 normalized

```{r compare_to_T0_normed, eval = TRUE}
#method - load original data
#filter to assays and features in DE data
#T0 normalize
#use combined18 cluster assignemnt in heatmap
load("~/Documents/MDD_Integrated/Data/assay_pk_data.rda")

cluster_assignments <- combined18_features_data_ann %>%
  select(Cluster, feature_type)

matched_features_types <- assay_pk_data %>%
    mutate(Type = case_when(Type == "RNA" ~"RNAseq",
                            TRUE ~ Type),
           ligand = case_when(ligand == "BMP2" ~"BMP2+EGF",
                              ligand == "IFNG" ~"IFNG+EGF",
                              ligand == "TGFB" ~"TGFB+EGF",
                              TRUE ~ ligand),
           feature = str_remove(feature, "_.*"),
           feature_type =  paste0(feature, "_", Type),
           condition = paste0(ligand,"_", experimentalTimePoint)) %>%
  select(-ligand, -feature, -Type, -experimentalTimePoint) %>%
  filter(feature_type %in% combined18_features_data_ann$feature_type,
         str_detect(condition, "_0|_24|_48")) 

assay_pk_data_T0_norm <- matched_features_types %>%
  filter(condition == "ctrl_0") %>%
  rename(ctrl_0_value = value) %>%
  select(-condition) %>%
  right_join(matched_features_types, by = "feature_type") %>%
  mutate(value_T0_norm = value-ctrl_0_value) %>%
  select(-ctrl_0_value, -value) %>%
pivot_wider(names_from = condition, values_from = value_T0_norm, values_fn = mean) %>%
  left_join(cluster_assignments, by = "feature_type")

#create heatmap of T0 data using DE cluster assignments
#create a numeric matrix with feature row names
assay_pk_data_T0_norm_dm <- assay_pk_data_T0_norm %>%
  select(-feature_type, -Cluster) %>%
  as.matrix() 

rownames(assay_pk_data_T0_norm_dm) <- assay_pk_data_T0_norm$feature_type
# combined18_features_dm <- combined18_features_dm[!is.nan(combined18_features_dm[,1]),]
assay_pk_data_T0_norm_ann <- assay_pk_data_T0_norm %>%
  select(feature_type, Cluster) %>%
  mutate(Type = str_remove(feature_type, ".*_")) %>%
  select(-feature_type) %>%
  as.data.frame()

haRow_T0 <- HeatmapAnnotation(df = assay_pk_data_T0_norm_ann,
                              which = "row",
                              col = list(Cluster = factor(cluster_cols, levels = cluster_cols, ordered = TRUE),
                                         Type = assay_cols))

hm_T0 <- Heatmap(assay_pk_data_T0_norm_dm,
        name = "fc ",
        column_title = "T0 Normalized",
        column_title_gp = gpar(fontsize = 12),
        col = colorRamp2(c(-1, 0, 1), c("#2166AC", "white", "#B2182B")),
        cluster_rows = FALSE,
        cluster_row_slices = FALSE,
        cluster_columns = FALSE,
        row_split = assay_pk_data_T0_norm$Cluster,
        #row_gap = unit(2, "mm"),
        row_title = " ",
        left_annotation = haRow_T0,
        show_row_names = FALSE,
        row_names_gp = gpar(fontsize = 8),
        column_names_gp = gpar(fontsize = 10),
        use_raster = FALSE)

hm_T0

#Make a heatmap of the mean values
assay_pk_data_T0_norm_mean <- assay_pk_data_T0_norm %>%
  pivot_longer(cols = matches("_0|24|48"), names_to = "condition") %>%
  group_by(condition, Cluster) %>%
  summarise(value_mean =mean(value)) %>%
  pivot_wider(names_from = condition, values_from = value_mean)
  
#create heatmap of T0 data using DE cluster assignments
#create a numeric matrix with feature row names
assay_pk_data_T0_norm_mean_dm <- assay_pk_data_T0_norm_mean %>%
  select(-Cluster) %>%
  as.matrix() 

rownames(assay_pk_data_T0_norm_mean_dm) <- assay_pk_data_T0_norm_mean$Cluster

hm_T0_mean <- Heatmap(assay_pk_data_T0_norm_mean_dm,
        name = "value ",
        column_title = "T0 Normalized means",
        column_title_gp = gpar(fontsize = 12),
        col = colorRamp2(c(-1, 0, 1), c("#2166AC", "white", "#B2182B")),
        cluster_rows = TRUE,
        cluster_row_slices = FALSE,
        cluster_columns = FALSE,
        #row_gap = unit(2, "mm"),
        row_title = " ",
        show_row_names = TRUE,
        row_names_gp = gpar(fontsize = 8),
        column_names_gp = gpar(fontsize = 10),
        use_raster = FALSE)

#barplots with clusters on x axis, mean values on y axis, facetted by condition
df <- assay_pk_data_T0_norm_mean %>%
  select(-ctrl_0) %>%
  pivot_longer(cols = matches("_0|24|48"), names_to = "condition")

p <- ggplot(df, aes(x = Cluster, y = value)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90)) +
  facet_wrap(~condition, ncol = 2)
p

if(create_pdfs){
  pdf("MDD_T0_normed_in_combined18_manual_clusters.pdf",height = 10)
  p
  draw(hm_T0)
  draw(hm_T0_mean)
  res <- dev.off()
} 

module_features <- assay_pk_data_T0_norm %>%
  arrange(Cluster) %>%
  mutate(Cluster = paste0("module_", Cluster),
         Cluster = factor(Cluster, levels = unique(Cluster))) %>%
  split(.$Cluster) 

res <- write_xlsx(module_features,
                  path = "MDD_T0_norm_combined18_tables.xlsx")

```

method - load original data  
filter to assays and features in DE data  
T0 normalize  
use combined18 cluster assignment in heatmap  

###